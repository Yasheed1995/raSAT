!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
*	camlside/IA.ml	/^    let ( * ) (i1: inf_interval) (i2: inf_interval) = i1 #mul i2 $/;"	f	Module:ICI
*	camlside/IA.ml	/^    let ( * ) (i1: interval) (i2: interval) = i1 #mul i2 $/;"	f	Module:CI
*	camlside/IA.ml	/^    let ( * ) (t1: af1) (t2: af1) = t1 #mul t2$/;"	f	Module:AF1
*	camlside/IA.ml	/^    let ( * ) (t1: af2) (t2: af2) = t1 #mul t2$/;"	f	Module:AF2
*	camlside/IA.ml	/^    let ( * ) (t1: caf2) (t2: caf2) = t1 #mul t2$/;"	f	Module:CAF2
*	camlside/IA.ml	/^    let ( * ) (t1: cai1) (t2: cai1) = t1 #mul t2$/;"	f	Module:CAI1
*	camlside/IA.ml	/^    let ( * ) (t1: cai2) (t2: cai2)   = t1 #mul t2$/;"	f	Module:CAI2
*	camlside/IA.ml	/^    let ( * ) (t1: cai3) (t2: cai3) = t1 #mul t2$/;"	f	Module:CAI3
*@	camlside/IA.ml	/^    let ( *@ )(c: float)(t: af1)  = t #mul2 c$/;"	f	Module:AF1
*@	camlside/IA.ml	/^    let ( *@) (c: float)         (i: inf_interval)  = i #mul2 c$/;"	f	Module:ICI
*@	camlside/IA.ml	/^    let ( *@) (c: float)     (i: interval)  = i #mul2 c$/;"	f	Module:CI
*@	camlside/IA.ml	/^    let ( *@) (c: float) (t: cai3)  = t #mul2 c$/;"	f	Module:CAI3
*@	camlside/IA.ml	/^    let ( *@) (c: float)(t: af2)  = t #mul2 c$/;"	f	Module:AF2
*@	camlside/IA.ml	/^    let ( *@) (c: float)(t: caf2)  = t #mul2 c$/;"	f	Module:CAF2
*@	camlside/IA.ml	/^    let ( *@) (c: float)(t: cai1)  = t #mul2 c$/;"	f	Module:CAI1
*@	camlside/IA.ml	/^    let ( *@) (c:float)(t: cai2)    = t #mul_cons (new interval c c)$/;"	f	Module:CAI2
+	camlside/IA.ml	/^    let ( + ) (i1: inf_interval) (i2: inf_interval) = i1 #add i2$/;"	f	Module:ICI
+	camlside/IA.ml	/^    let ( + ) (i1: interval) (i2: interval) = i1 #add i2$/;"	f	Module:CI
+	camlside/IA.ml	/^    let ( + ) (t1: af1) (t2: af1) = t1 #add t2$/;"	f	Module:AF1
+	camlside/IA.ml	/^    let ( + ) (t1: af2) (t2: af2) = t1 #add t2$/;"	f	Module:AF2
+	camlside/IA.ml	/^    let ( + ) (t1: caf2) (t2: caf2) = t1 #add t2$/;"	f	Module:CAF2
+	camlside/IA.ml	/^    let ( + ) (t1: cai1) (t2: cai1) = t1 #add t2$/;"	f	Module:CAI1
+	camlside/IA.ml	/^    let ( + ) (t1: cai2) (t2: cai2)   = t1 #add t2$/;"	f	Module:CAI2
+	camlside/IA.ml	/^    let ( + ) (t1: cai3) (t2: cai3) = t1 #add t2$/;"	f	Module:CAI3
+@	camlside/IA.ml	/^    let ( +@) (i: inf_interval)  (c: float)         = i #add2 c$/;"	f	Module:ICI
+@	camlside/IA.ml	/^    let ( +@) (i: interval)  (c: float)     = i #add2 c$/;"	f	Module:CI
+@	camlside/IA.ml	/^    let ( +@) (t: af1)  (c: float)= t #add2 c$/;"	f	Module:AF1
+@	camlside/IA.ml	/^    let ( +@) (t: af2)  (c: float)= t #add2 c$/;"	f	Module:AF2
+@	camlside/IA.ml	/^    let ( +@) (t: caf2)  (c: float)= t #add2 c$/;"	f	Module:CAF2
+@	camlside/IA.ml	/^    let ( +@) (t: cai1)  (c: float)= t #add2 c$/;"	f	Module:CAI1
+@	camlside/IA.ml	/^    let ( +@) (t: cai2)  (c: float) = t #add2 c$/;"	f	Module:CAI2
+@	camlside/IA.ml	/^    let ( +@) (t: cai3)  (c: float) = t #add2 c$/;"	f	Module:CAI3
-	camlside/IA.ml	/^    let ( - ) (i1: inf_interval) (i2: inf_interval) = i1 #sub i2   $/;"	f	Module:ICI
-	camlside/IA.ml	/^    let ( - ) (i1: interval) (i2: interval) = i1 #sub i2   $/;"	f	Module:CI
-	camlside/IA.ml	/^    let ( - ) (t1: af1) (t2: af1) = t1 #sub t2$/;"	f	Module:AF1
-	camlside/IA.ml	/^    let ( - ) (t1: af2) (t2: af2) = t1 #sub t2$/;"	f	Module:AF2
-	camlside/IA.ml	/^    let ( - ) (t1: caf2) (t2: caf2) = t1 #sub t2$/;"	f	Module:CAF2
-	camlside/IA.ml	/^    let ( - ) (t1: cai1) (t2: cai1) = t1 #sub t2$/;"	f	Module:CAI1
-	camlside/IA.ml	/^    let ( - ) (t1: cai2) (t2: cai2)   = t1 #sub t2$/;"	f	Module:CAI2
-	camlside/IA.ml	/^    let ( - ) (t1: cai3) (t2: cai3)  = t1 #sub t2$/;"	f	Module:CAI3
-@	camlside/IA.ml	/^    let ( -@ )(t: af1)  (c: float)= t #sub2 c$/;"	f	Module:AF1
-@	camlside/IA.ml	/^    let ( -@ )(t: cai1)  (c: float)= t #sub2 c$/;"	f	Module:CAI1
-@	camlside/IA.ml	/^    let ( -@ )(t: cai2)  (c: float) = t #sub2 c$/;"	f	Module:CAI2
-@	camlside/IA.ml	/^    let ( -@) (i: inf_interval)  (c: float)         = i #sub2 c  $/;"	f	Module:ICI
-@	camlside/IA.ml	/^    let ( -@) (i: interval)  (c: float)     = i #sub2 c   $/;"	f	Module:CI
-@	camlside/IA.ml	/^    let ( -@) (t: af2)  (c: float)= t #sub2 c$/;"	f	Module:AF2
-@	camlside/IA.ml	/^    let ( -@) (t: caf2)  (c: float)= t #sub2 c$/;"	f	Module:CAF2
-@	camlside/IA.ml	/^    let ( -@) (t: cai3)  (c: float) = t #sub2 c$/;"	f	Module:CAI3
<	camlside/IA.ml	/^    let ( < ) (i1: bound) (i2: bound) = le i1 i2  $/;"	f	Module:ICI
<=	camlside/IA.ml	/^    let ( <= )(i1: bound) (i2: bound) = leq i1 i2 $/;"	f	Module:ICI
==	camlside/IA.ml	/^    let ( == )(i1: bound) (i2: bound) = eq i1 i2  $/;"	f	Module:ICI
>	camlside/IA.ml	/^    let ( > ) (i1: bound) (i2: bound) = ge i1 i2  $/;"	f	Module:ICI
>=	camlside/IA.ml	/^    let ( >= )(i1: bound) (i2: bound) = geq i1 i2  $/;"	f	Module:ICI
AF1	camlside/IA.ml	/^  module AF1 = struct$/;"	M
AF1	camlside/file.h	/^const int AF1  = 2;              \/\/Affine Form of interval 1$/;"	v
AF1	solver/file.h	/^const int AF1  = 1;              \/\/Affine Form of interval 1$/;"	v
AF2	camlside/IA.ml	/^  module AF2 = struct$/;"	M
AF2	camlside/file.h	/^const int AF2  = 3;              \/\/Affine Form of interval 2$/;"	v
AF2	solver/file.h	/^const int AF2  = 2;              \/\/Affine Form of interval 2$/;"	v
AND	camlside/Caml_Smt.ml	/^  | AND of nil_expr * nil_expr $/;"	C	type:Caml/nil_expr
AND	camlside/SmtParser.ml	/^  | AND$/;"	C	type:token
AND	camlside/SmtParser.mli	/^  | AND$/;"	C	type:token
AND	camlside/parser.ml	/^  | AND$/;"	C	type:token
AND	camlside/parser.mli	/^  | AND$/;"	C	type:token
AND	solver/Caml.ml	/^  | AND of nil_expr * nil_expr $/;"	C	type:nil_expr
ASSERT	camlside/SmtParser.ml	/^  | ASSERT$/;"	C	type:token
ASSERT	camlside/SmtParser.mli	/^  | ASSERT$/;"	C	type:token
ASSERT	camlside/parser.ml	/^  | ASSERT$/;"	C	type:token
ASSERT	camlside/parser.mli	/^  | ASSERT$/;"	C	type:token
Add	camlside/Exp.ml	/^  | Add of smt_poly_expr * smt_poly_expr $/;"	C	type:smt_poly_expr
Add	camlside/ast.ml	/^  | Add of poly_expr * poly_expr $/;"	C	type:poly_expr
And	camlside/Exp.ml	/^  | And of smt_bool_expr * smt_bool_expr$/;"	C	type:smt_bool_expr
And	camlside/ast.ml	/^  | And of bool_expr * bool_expr$/;"	C	type:bool_expr
As	camlside/Exp.ml	/^  | As of let_expr * ass_expr$/;"	C	type:ass_expr
Ass	camlside/ast.ml	/^  | Ass of bool_expr$/;"	C	type:formula
Ast	camlside/ast.ml	/^(*raSAT expression*)$/;"	M
BC	camlside/Caml_Smt.ml	/^  | BC of smt_bool_expr$/;"	C	type:Caml/nil_expr
BC	solver/Caml.ml	/^  | BC of smt_bool_expr$/;"	C	type:nil_expr
BEq	camlside/Exp.ml	/^  | BEq of string * smt_bool_expr$/;"	C	type:let_expr
BVar	camlside/Exp.ml	/^  | BVar of string$/;"	C	type:smt_bool_expr
BoolOption	utils/Options.h	/^    BoolOption(const char* c, const char* n, const char* d, bool v) $/;"	f	class:Minisat::BoolOption
BoolOption	utils/Options.h	/^class BoolOption : public Option$/;"	c	namespace:Minisat
CAF	camlside/file.h	/^const int CAF  = 4;              \/\/Chebyshev Affine Form of interval $/;"	v
CAF2	camlside/IA.ml	/^  module CAF2 = struct$/;"	M
CAI1	camlside/IA.ml	/^  module CAI1 = struct$/;"	M
CAI1	solver/file.h	/^const int CAI1 = 3;              \/\/Chebyshev Affine Form of interval $/;"	v
CAI2	camlside/IA.ml	/^  module CAI2 = struct$/;"	M
CAI2	solver/file.h	/^const int CAI2 = 4;              \/\/Extend Chebyshev Affine Form of interval $/;"	v
CAI3	camlside/IA.ml	/^  module CAI3 = struct$/;"	M
CAI3	solver/file.h	/^const int CAI3 = 5;              \/\/Otptimized Extended Chebyshev Affine Form of interval $/;"	v
CAMLLIB	mtl/template.mk	/^CAMLLIB 	= $(MROOT)\/camlside\/camllib.a$/;"	m
CC	camlside/Makefile	/^CC=g++$/;"	m
CFLAGS	mtl/template.mk	/^CFLAGS    ?= -Wall -Wno-parentheses$/;"	m
CHDRS	mtl/template.mk	/^CHDRS      = $(wildcard $(PWD)\/*.h)$/;"	m
CI	camlside/IA.ml	/^  module CI = struct$/;"	M
CI	camlside/file.h	/^const int CI   = 1;              \/\/Classical Interval$/;"	v
CI	solver/file.h	/^const int CI   = 0;              \/\/Classical Interval$/;"	v
CMap	solver/SolverTypes.h	/^class CMap$/;"	c	namespace:Minisat
COBJS	mtl/template.mk	/^COBJS      = $(CSRCS:.cc=.o) $(DSRCS:.cc=.o)$/;"	m
CONJ	camlside/SmtParser.ml	/^  | CONJ$/;"	C	type:token
CONJ	camlside/SmtParser.mli	/^  | CONJ$/;"	C	type:token
COPTIMIZE	mtl/template.mk	/^COPTIMIZE ?= -O3$/;"	m
CRef	solver/SolverTypes.h	/^typedef RegionAllocator<uint32_t>::Ref CRef;$/;"	t	namespace:Minisat
CRefHash	solver/SolverTypes.h	/^    struct CRefHash {$/;"	s	class:Minisat::CMap
CRef_Undef	solver/SolverTypes.h	/^const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;$/;"	m	namespace:Minisat
CSRCS	mtl/template.mk	/^CSRCS      = $(wildcard $(PWD)\/*.cc) $/;"	m
CXX	mtl/template.mk	/^CXX       ?= g++$/;"	m
Caml	camlside/Caml.ml	/^module Caml = struct$/;"	M
Caml	camlside/Caml.ml	/^open Ast           (*type: literal, clause, formula... declaration*)   $/;"	M
Caml	camlside/Caml_Smt.ml	/^module Caml = struct$/;"	M
Caml	solver/Caml.ml	/^module Caml = struct$/;"	M
Caml	solver/Caml.ml	/^open Ast           (*type: literal, clause, formula... declaration*)   $/;"	M
Caml_Smt	camlside/Caml_Smt.ml	/^open Exp           (*type: literal, clause, formula... declaration*)   $/;"	M
Ch	camlside/Exp.ml	/^  | Ch of smt_bool_expr$/;"	C	type:ass_expr
Cl	camlside/ast.ml	/^  | Cl of intv_clause$/;"	C	type:intv_expr
Clause	solver/SolverTypes.h	/^    Clause(const V& ps, bool use_extra, bool learnt) {$/;"	f	class:Minisat::Clause
Clause	solver/SolverTypes.h	/^class Clause {$/;"	c	namespace:Minisat
ClauseAllocator	solver/SolverTypes.h	/^    ClauseAllocator() : extra_clause_field(false){}$/;"	f	class:Minisat::ClauseAllocator
ClauseAllocator	solver/SolverTypes.h	/^    ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}$/;"	f	class:Minisat::ClauseAllocator
ClauseAllocator	solver/SolverTypes.h	/^class ClauseAllocator : public RegionAllocator<uint32_t>$/;"	c	namespace:Minisat
Conj	camlside/Exp.ml	/^  | Conj of ass_expr * ass_expr$/;"	C	type:ass_expr
DCOBJS	mtl/template.mk	/^DCOBJS     = $(addsuffix d,  $(COBJS))$/;"	m
DEPDIR	solver/Makefile	/^DEPDIR    = mtl utils$/;"	m
DEPDIR	utils/Makefile	/^DEPDIR    = mtl$/;"	m
DIV	camlside/SmtParser.ml	/^  | DIV$/;"	C	type:token
DIV	camlside/SmtParser.mli	/^  | DIV$/;"	C	type:token
DSRCS	mtl/template.mk	/^DSRCS      = $(foreach dir, $(DEPDIR), $(filter-out $(MROOT)\/$(dir)\/Main.cc, $(wildcard $(MROOT)\/$(dir)\/*.cc)))$/;"	m
DeepEqual	mtl/Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };$/;"	s	namespace:Minisat
DeepHash	mtl/Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };$/;"	s	namespace:Minisat
Div	camlside/Exp.ml	/^  | Div of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_poly_expr
DoubleOption	utils/Options.h	/^    DoubleOption(const char* c, const char* n, const char* d, double def = double(), DoubleRange r = DoubleRange(-HUGE_VAL, false, HUGE_VAL, false))$/;"	f	class:Minisat::DoubleOption
DoubleOption	utils/Options.h	/^class DoubleOption : public Option$/;"	c	namespace:Minisat
DoubleRange	utils/Options.h	/^    DoubleRange(double b, bool binc, double e, bool einc) : begin(b), end(e), begin_inclusive(binc), end_inclusive(einc) {}$/;"	f	struct:Minisat::DoubleRange
DoubleRange	utils/Options.h	/^struct DoubleRange {$/;"	s	namespace:Minisat
EOF	camlside/SmtParser.ml	/^  | EOF$/;"	C	type:token
EOF	camlside/SmtParser.mli	/^  | EOF$/;"	C	type:token
EOF	camlside/parser.ml	/^  | EOF$/;"	C	type:token
EOF	camlside/parser.mli	/^  | EOF$/;"	C	type:token
EQ	camlside/SmtParser.ml	/^  | EQ$/;"	C	type:token
EQ	camlside/SmtParser.mli	/^  | EQ$/;"	C	type:token
EQ	camlside/parser.ml	/^  | EQ$/;"	C	type:token
EQ	camlside/parser.mli	/^  | EQ$/;"	C	type:token
EXEC	mtl/template.mk	/^EXEC      ?= $(notdir $(PWD))$/;"	m
EXEC	solver/Makefile	/^EXEC      = raSAT$/;"	m
EXEC	utils/Makefile	/^EXEC      = system_test$/;"	m
Eq	camlside/Exp.ml	/^  | Eq of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_bool_expr
Eq	camlside/ast.ml	/^  | Eq of poly_expr * poly_expr$/;"	C	type:bool_expr
Equal	mtl/Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };$/;"	s	namespace:Minisat
Exp	camlside/Exp.ml	/^(*SMT expression*)$/;"	M
Expr	camlside/Expr.ml	/^module Expr = struct$/;"	M
Expr	camlside/Expr.ml	/^open Exp$/;"	M
Float	camlside/IA.ml	/^  type bound = Float of float | Neg_inf | Pos_inf$/;"	C	type:IA/bound
GEQ	camlside/SmtParser.ml	/^  | GEQ$/;"	C	type:token
GEQ	camlside/SmtParser.mli	/^  | GEQ$/;"	C	type:token
GEQ	camlside/parser.ml	/^  | GEQ$/;"	C	type:token
GEQ	camlside/parser.mli	/^  | GEQ$/;"	C	type:token
GR	camlside/SmtParser.ml	/^  | GR$/;"	C	type:token
GR	camlside/SmtParser.mli	/^  | GR$/;"	C	type:token
GR	camlside/parser.ml	/^  | GR$/;"	C	type:token
GR	camlside/parser.mli	/^  | GR$/;"	C	type:token
Geq	camlside/Exp.ml	/^  | Geq of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_bool_expr
Geq	camlside/ast.ml	/^  | Geq of poly_expr * poly_expr$/;"	C	type:bool_expr
Gr	camlside/Exp.ml	/^  | Gr of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_bool_expr
Gr	camlside/ast.ml	/^  | Gr of poly_expr * poly_expr$/;"	C	type:bool_expr
Hash	mtl/Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };$/;"	s	namespace:Minisat
HashTable	solver/SolverTypes.h	/^    typedef Map<CRef, T, CRefHash> HashTable;$/;"	t	class:Minisat::CMap
Heap	mtl/Heap.h	/^    Heap(const Comp& c) : lt(c) { }$/;"	f	class:Minisat::Heap
Heap	mtl/Heap.h	/^class Heap {$/;"	c	namespace:Minisat
IA	camlside/IA.ml	/^module IA = struct$/;"	M
IC	camlside/parser.ml	/^  | IC$/;"	C	type:token
IC	camlside/parser.mli	/^  | IC$/;"	C	type:token
ICI	camlside/IA.ml	/^  module ICI = struct$/;"	M
ID	camlside/SmtParser.ml	/^  | ID of (string)$/;"	C	type:token
ID	camlside/SmtParser.mli	/^  | ID of (string)$/;"	C	type:token
ID	camlside/parser.ml	/^  | ID of (string)$/;"	C	type:token
ID	camlside/parser.mli	/^  | ID of (string)$/;"	C	type:token
IN	camlside/parser.ml	/^  | IN$/;"	C	type:token
IN	camlside/parser.mli	/^  | IN$/;"	C	type:token
Ic	camlside/ast.ml	/^  | Ic of intv_expr * intv_expr            (*Ic: Interval constraints *)$/;"	C	type:intv_expr
In	camlside/ast.ml	/^  | In of string * float * float$/;"	C	type:intv_clause
Int64Option	utils/Options.h	/^    Int64Option(const char* c, const char* n, const char* d, int64_t def = int64_t(), Int64Range r = Int64Range(INT64_MIN, INT64_MAX))$/;"	f	class:Minisat::Int64Option
Int64Option	utils/Options.h	/^class Int64Option : public Option$/;"	c	namespace:Minisat
Int64Range	utils/Options.h	/^    Int64Range(int64_t b, int64_t e) : begin(b), end(e) {}$/;"	f	struct:Minisat::Int64Range
Int64Range	utils/Options.h	/^struct Int64Range {$/;"	s	namespace:Minisat
IntOption	utils/Options.h	/^    IntOption(const char* c, const char* n, const char* d, int32_t def = int32_t(), IntRange r = IntRange(INT32_MIN, INT32_MAX))$/;"	f	class:Minisat::IntOption
IntOption	utils/Options.h	/^class IntOption : public Option$/;"	c	namespace:Minisat
IntRange	utils/Options.h	/^    IntRange(int b, int e) : begin(b), end(e) {}$/;"	f	struct:Minisat::IntRange
IntRange	utils/Options.h	/^struct IntRange {$/;"	s	namespace:Minisat
Intv	camlside/ast.ml	/^  | Intv of intv_expr  $/;"	C	type:formula
Key	mtl/Queue.h	/^    typedef T Key;$/;"	t	class:Minisat::Queue
LE	camlside/SmtParser.ml	/^  | LE$/;"	C	type:token
LE	camlside/SmtParser.mli	/^  | LE$/;"	C	type:token
LE	camlside/parser.ml	/^  | LE$/;"	C	type:token
LE	camlside/parser.mli	/^  | LE$/;"	C	type:token
LEQ	camlside/SmtParser.ml	/^  | LEQ$/;"	C	type:token
LEQ	camlside/SmtParser.mli	/^  | LEQ$/;"	C	type:token
LEQ	camlside/parser.ml	/^  | LEQ$/;"	C	type:token
LEQ	camlside/parser.mli	/^  | LEQ$/;"	C	type:token
LET	camlside/SmtParser.ml	/^  | LET$/;"	C	type:token
LET	camlside/SmtParser.mli	/^  | LET$/;"	C	type:token
LFLAGS	mtl/template.mk	/^LFLAGS    ?= -Wall$/;"	m
LPAREN	camlside/SmtParser.ml	/^  | LPAREN$/;"	C	type:token
LPAREN	camlside/SmtParser.mli	/^  | LPAREN$/;"	C	type:token
LPAREN	camlside/parser.ml	/^  | LPAREN$/;"	C	type:token
LPAREN	camlside/parser.mli	/^  | LPAREN$/;"	C	type:token
Le	camlside/Exp.ml	/^  | Le of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_bool_expr
Le	camlside/ast.ml	/^  | Le of poly_expr * poly_expr$/;"	C	type:bool_expr
Leq	camlside/Exp.ml	/^  | Leq of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_bool_expr
Leq	camlside/ast.ml	/^  | Leq of poly_expr * poly_expr$/;"	C	type:bool_expr
LessThan_default	mtl/Sort.h	/^struct LessThan_default {$/;"	s	namespace:Minisat
Let	camlside/Exp.ml	/^  | Let of let_expr * let_expr$/;"	C	type:let_expr
Lexer	camlside/lexer.ml	/^# 1 "lexer.mll"$/;"	M
Lit	solver/SolverTypes.h	/^struct Lit {$/;"	s	namespace:Minisat
MINUS	camlside/SmtParser.ml	/^  | MINUS$/;"	C	type:token
MINUS	camlside/SmtParser.mli	/^  | MINUS$/;"	C	type:token
MINUS	camlside/parser.ml	/^  | MINUS$/;"	C	type:token
MINUS	camlside/parser.mli	/^  | MINUS$/;"	C	type:token
Map	mtl/Map.h	/^                   Map        (Map<K,D,H,E>& other) { assert(0); }$/;"	f	class:Minisat::Map
Map	mtl/Map.h	/^    Map () : table(NULL), cap(0), size(0) {}$/;"	f	class:Minisat::Map
Map	mtl/Map.h	/^    Map (const H& h, const E& e) : hash(h), equals(e), table(NULL), cap(0), size(0){}$/;"	f	class:Minisat::Map
Map	mtl/Map.h	/^class Map {$/;"	c	namespace:Minisat
Minisat	mtl/Alg.h	/^namespace Minisat {$/;"	n
Minisat	mtl/Alloc.h	/^namespace Minisat {$/;"	n
Minisat	mtl/Heap.h	/^namespace Minisat {$/;"	n
Minisat	mtl/Map.h	/^namespace Minisat {$/;"	n
Minisat	mtl/Queue.h	/^namespace Minisat {$/;"	n
Minisat	mtl/Sort.h	/^namespace Minisat {$/;"	n
Minisat	mtl/Vec.h	/^namespace Minisat {$/;"	n
Minisat	mtl/XAlloc.h	/^namespace Minisat {$/;"	n
Minisat	solver/Dimacs.h	/^namespace Minisat {$/;"	n
Minisat	solver/Solver.h	/^namespace Minisat {$/;"	n
Minisat	solver/SolverTypes.h	/^namespace Minisat {$/;"	n
Minisat	utils/Options.h	/^namespace Minisat {$/;"	n
Minisat	utils/ParseUtils.h	/^namespace Minisat {$/;"	n
Minisat	utils/System.h	/^namespace Minisat {$/;"	n
Minisat_Alg_h	mtl/Alg.h	/^#define Minisat_Alg_h$/;"	d
Minisat_Alloc_h	mtl/Alloc.h	/^#define Minisat_Alloc_h$/;"	d
Minisat_Dimacs_h	solver/Dimacs.h	/^#define Minisat_Dimacs_h$/;"	d
Minisat_Heap_h	mtl/Heap.h	/^#define Minisat_Heap_h$/;"	d
Minisat_IntTypes_h	mtl/IntTypes.h	/^#define Minisat_IntTypes_h$/;"	d
Minisat_Map_h	mtl/Map.h	/^#define Minisat_Map_h$/;"	d
Minisat_Options_h	utils/Options.h	/^#define Minisat_Options_h$/;"	d
Minisat_ParseUtils_h	utils/ParseUtils.h	/^#define Minisat_ParseUtils_h$/;"	d
Minisat_Queue_h	mtl/Queue.h	/^#define Minisat_Queue_h$/;"	d
Minisat_SolverTypes_h	solver/SolverTypes.h	/^#define Minisat_SolverTypes_h$/;"	d
Minisat_Solver_h	solver/Solver.h	/^#define Minisat_Solver_h$/;"	d
Minisat_Sort_h	mtl/Sort.h	/^#define Minisat_Sort_h$/;"	d
Minisat_System_h	utils/System.h	/^#define Minisat_System_h$/;"	d
Minisat_Vec_h	mtl/Vec.h	/^#define Minisat_Vec_h$/;"	d
Minisat_XAlloc_h	mtl/XAlloc.h	/^#define Minisat_XAlloc_h$/;"	d
Mul	camlside/Exp.ml	/^  | Mul of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_poly_expr
Mul	camlside/ast.ml	/^  | Mul of poly_expr * poly_expr$/;"	C	type:poly_expr
MultiVar	camlside/Expr.ml	/^module MultiVar = struct $/;"	M
NOT	camlside/SmtParser.ml	/^  | NOT$/;"	C	type:token
NOT	camlside/SmtParser.mli	/^  | NOT$/;"	C	type:token
NUM	camlside/SmtParser.ml	/^  | NUM of (string)$/;"	C	type:token
NUM	camlside/SmtParser.mli	/^  | NUM of (string)$/;"	C	type:token
NUM	camlside/parser.ml	/^  | NUM of (string)$/;"	C	type:token
NUM	camlside/parser.mli	/^  | NUM of (string)$/;"	C	type:token
Neg_inf	camlside/IA.ml	/^  type bound = Float of float | Neg_inf | Pos_inf$/;"	C	type:IA/bound
Nil	camlside/Caml_Smt.ml	/^  | Nil$/;"	C	type:Caml/nil_expr
Nil	solver/Caml.ml	/^  | Nil$/;"	C	type:nil_expr
Not	camlside/Exp.ml	/^  | Not of smt_bool_expr$/;"	C	type:smt_bool_expr
OC	camlside/Makefile	/^OC=ocamlopt$/;"	m
OCAML_LIB	camlside/Makefile	/^OCAML_LIB=camllib.a$/;"	m
OR	camlside/SmtParser.ml	/^  | OR$/;"	C	type:token
OR	camlside/SmtParser.mli	/^  | OR$/;"	C	type:token
OR	camlside/parser.ml	/^  | OR$/;"	C	type:token
OR	camlside/parser.mli	/^  | OR$/;"	C	type:token
OccLists	solver/SolverTypes.h	/^    OccLists(const Deleted& d) : deleted(d) {}$/;"	f	class:Minisat::OccLists
OccLists	solver/SolverTypes.h	/^class OccLists$/;"	c	namespace:Minisat
Option	utils/Options.h	/^    Option(const char* name_, $/;"	f	class:Minisat::Option
Option	utils/Options.h	/^class Option$/;"	c	namespace:Minisat
OptionLt	utils/Options.h	/^    struct OptionLt {$/;"	s	class:Minisat::Option
Or	camlside/ast.ml	/^  | Or of intv_clause * intv_clause                $/;"	C	type:intv_clause
OutOfMemoryException	mtl/XAlloc.h	/^class OutOfMemoryException{};$/;"	c	namespace:Minisat
PCOBJS	mtl/template.mk	/^PCOBJS     = $(addsuffix p,  $(COBJS))$/;"	m
PEq	camlside/Exp.ml	/^  | PEq of string * smt_poly_expr$/;"	C	type:let_expr
PLUS	camlside/SmtParser.ml	/^  | PLUS$/;"	C	type:token
PLUS	camlside/SmtParser.mli	/^  | PLUS$/;"	C	type:token
PLUS	camlside/parser.ml	/^  | PLUS$/;"	C	type:token
PLUS	camlside/parser.mli	/^  | PLUS$/;"	C	type:token
POWER	camlside/SmtParser.ml	/^  | POWER$/;"	C	type:token
POWER	camlside/SmtParser.mli	/^  | POWER$/;"	C	type:token
POWER	camlside/parser.ml	/^  | POWER$/;"	C	type:token
POWER	camlside/parser.mli	/^  | POWER$/;"	C	type:token
PWD	mtl/template.mk	/^PWD        = $(shell pwd)$/;"	m
Pair	mtl/Map.h	/^    struct Pair { K key; D data; };$/;"	s	class:Minisat::Map
Parser	camlside/parser.ml	/^type token =$/;"	M
Parser	camlside/parser.mli	/^type token =$/;"	M
Poly	camlside/Expr.ml	/^module Poly = Map.Make(MultiVar) $/;"	M
Pos_inf	camlside/IA.ml	/^  type bound = Float of float | Neg_inf | Pos_inf$/;"	C	type:IA/bound
Pow	camlside/Exp.ml	/^  | Pow of smt_poly_expr * int$/;"	C	type:smt_poly_expr
Pow	camlside/ast.ml	/^  | Pow of poly_expr * int$/;"	C	type:poly_expr
Queue	mtl/Queue.h	/^    Queue() : buf(1), first(0), end(0) {}$/;"	f	class:Minisat::Queue
Queue	mtl/Queue.h	/^class Queue {$/;"	c	namespace:Minisat
RCOBJS	mtl/template.mk	/^RCOBJS     = $(addsuffix r,  $(COBJS))$/;"	m
RESULT	camlside/Makefile	/^RESULT = a$/;"	m
RPAREN	camlside/SmtParser.ml	/^  | RPAREN$/;"	C	type:token
RPAREN	camlside/SmtParser.mli	/^  | RPAREN$/;"	C	type:token
RPAREN	camlside/parser.ml	/^  | RPAREN$/;"	C	type:token
RPAREN	camlside/parser.mli	/^  | RPAREN$/;"	C	type:token
Real	camlside/Exp.ml	/^  | Real of float$/;"	C	type:smt_poly_expr
Real	camlside/ast.ml	/^  | Real of float$/;"	C	type:poly_expr
Ref	mtl/Alloc.h	/^    typedef uint32_t Ref;$/;"	t	class:Minisat::RegionAllocator
Ref_Undef	mtl/Alloc.h	/^    enum { Ref_Undef = UINT32_MAX };$/;"	e	enum:Minisat::RegionAllocator::__anon3
RegionAllocator	mtl/Alloc.h	/^    explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }$/;"	f	class:Minisat::RegionAllocator
RegionAllocator	mtl/Alloc.h	/^class RegionAllocator$/;"	c	namespace:Minisat
SIGINT_exit	solver/Main.cc	/^static void SIGINT_exit(int signum) {$/;"	f	file:
SIGINT_interrupt	solver/Main.cc	/^static void SIGINT_interrupt(int signum) { solver->interrupt(); }$/;"	f	file:
SOURCES	camlside/Makefile	/^SOURCES = ast.ml parser.mly lexer.mll Exp.ml SmtParser.mly SmtLexer.mll Expr.ml IA.ml Util.ml str.cma Caml.ml Caml_Smt.ml$/;"	m
SUBVAR	camlside/SmtParser.ml	/^  | SUBVAR of (string)$/;"	C	type:token
SUBVAR	camlside/SmtParser.mli	/^  | SUBVAR of (string)$/;"	C	type:token
SmtLexer	camlside/SmtLexer.ml	/^# 1 "SmtLexer.mll"$/;"	M
SmtParser	camlside/SmtParser.ml	/^type token =$/;"	M
SmtParser	camlside/SmtParser.mli	/^type token =$/;"	M
Solver	solver/Solver.cc	/^Solver::Solver() :$/;"	f	class:Solver
Solver	solver/Solver.h	/^class Solver {$/;"	c	namespace:Minisat
StreamBuffer	utils/ParseUtils.h	/^    explicit StreamBuffer(gzFile i) : in(i), pos(0), size(0) { assureLookahead(); }$/;"	f	class:Minisat::StreamBuffer
StreamBuffer	utils/ParseUtils.h	/^class StreamBuffer {$/;"	c	namespace:Minisat
StringOption	utils/Options.h	/^    StringOption(const char* c, const char* n, const char* d, const char* def = NULL) $/;"	f	class:Minisat::StringOption
StringOption	utils/Options.h	/^class StringOption : public Option$/;"	c	namespace:Minisat
Sub	camlside/Exp.ml	/^  | Sub of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_poly_expr
Sub	camlside/ast.ml	/^  | Sub of poly_expr * poly_expr$/;"	C	type:poly_expr
SubVar	camlside/Exp.ml	/^  | SubVar of string$/;"	C	type:smt_poly_expr
TIMES	camlside/SmtParser.ml	/^  | TIMES$/;"	C	type:token
TIMES	camlside/SmtParser.mli	/^  | TIMES$/;"	C	type:token
TIMES	camlside/parser.ml	/^  | TIMES$/;"	C	type:token
TIMES	camlside/parser.mli	/^  | TIMES$/;"	C	type:token
Unit_Size	mtl/Alloc.h	/^    enum { Unit_Size = sizeof(uint32_t) };$/;"	e	enum:Minisat::RegionAllocator::__anon4
Util	camlside/Util.ml	/^module Util = struct$/;"	M
Util	camlside/Util.ml	/^open IA;;$/;"	M
Var	camlside/Exp.ml	/^  | Var of string$/;"	C	type:smt_poly_expr
Var	camlside/ast.ml	/^  | Var of string$/;"	C	type:poly_expr
Var	solver/SolverTypes.h	/^typedef int Var;$/;"	t	namespace:Minisat
VarData	solver/Solver.h	/^    struct VarData { CRef reason; int level; };$/;"	s	class:Minisat::Solver
VarOrderLt	solver/Solver.h	/^        VarOrderLt(const vec<double>&  act) : activity(act) { }$/;"	f	struct:Minisat::Solver::VarOrderLt
VarOrderLt	solver/Solver.h	/^    struct VarOrderLt {$/;"	s	class:Minisat::Solver
Watcher	solver/Solver.h	/^        Watcher(CRef cr, Lit p) : cref(cr), blocker(p) {}$/;"	f	struct:Minisat::Solver::Watcher
Watcher	solver/Solver.h	/^    struct Watcher {$/;"	s	class:Minisat::Solver
WatcherDeleted	solver/Solver.h	/^        WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}$/;"	f	struct:Minisat::Solver::WatcherDeleted
WatcherDeleted	solver/Solver.h	/^    struct WatcherDeleted$/;"	s	class:Minisat::Solver
^	camlside/IA.ml	/^    let ( ^ ) (t: af1 ) (n: int)  = pow t n    $/;"	f	Module:AF1
^	camlside/IA.ml	/^    let ( ^ ) (t: af2)  (n: int)  = pow t n$/;"	f	Module:AF2
^	camlside/IA.ml	/^    let ( ^ ) (t: caf2)  (n: int)  = pow t n$/;"	f	Module:CAF2
^	camlside/IA.ml	/^    let ( ^ ) (t: cai1)  (n: int)  = pow t n$/;"	f	Module:CAI1
^	camlside/IA.ml	/^    let ( ^ ) (t: cai2)  (n: int)   = pow t n$/;"	f	Module:CAI2
^	camlside/IA.ml	/^    let ( ^ ) (t: cai3)  (n: int)   = pow t n$/;"	f	Module:CAI3
^	camlside/IA.ml	/^    let ( ^)  (i: inf_interval)  (n: int)           = i #pow n    $/;"	f	Module:ICI
^	camlside/IA.ml	/^    let ( ^)  (i: interval)  (n: int)       = i #pow n    $/;"	f	Module:CI
_cat	solver/Solver.cc	/^static const char* _cat = "CORE";$/;"	v	file:
_insert	mtl/Map.h	/^    void   _insert (const K& k, const D& d) { $/;"	f	class:Minisat::Map
a	camlside/IA.ml	/^      method a = a$/;"	m	class:af1
a	camlside/IA.ml	/^      method a = a$/;"	m	class:af2
a	camlside/IA.ml	/^      method a = a$/;"	m	class:caf2
a	camlside/IA.ml	/^      method a = a$/;"	m	class:cai1
a	camlside/IA.ml	/^      method a = a$/;"	m	class:cai2
a	camlside/IA.ml	/^      method a = a$/;"	m	class:cai3
a	camlside/IA.ml	/^      val mutable a  = (new interval 0.0 0.0: interval)   (*coeff of free var*)$/;"	v	class:caf2
a	camlside/IA.ml	/^      val mutable a  = (new interval 0.0 0.0: interval)   (*coeff of free var*)$/;"	v	class:cai1
a	camlside/IA.ml	/^      val mutable a  = (new interval 0.0 0.0: interval)   (*coeff of free var*)$/;"	v	class:cai2
a	camlside/IA.ml	/^      val mutable a  = (new interval 0.0 0.0: interval)   (*coeff of free var*)$/;"	v	class:cai3
a	camlside/IA.ml	/^      val mutable a = (0.0: float)   (*coeff of free var*)$/;"	v	class:af2
a	camlside/IA.ml	/^      val mutable a = (0.0: float)  (*coeff of free var*)$/;"	v	class:af1
abs	solver/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon2
abs_float	camlside/Caml_Smt.ml	/^let abs_float (num: float) =$/;"	v	Module:Caml
abstractLevel	solver/Solver.h	/^inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }$/;"	f	class:Minisat::Solver
abstraction	solver/SolverTypes.h	/^    uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }$/;"	f	class:Minisat::Clause
act	solver/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon2
activity	solver/Solver.h	/^        const vec<double>&  activity;$/;"	m	struct:Minisat::Solver::VarOrderLt
activity	solver/Solver.h	/^    vec<double>         activity;         \/\/ A heuristic measurement of the activity of a variable.$/;"	m	class:Minisat::Solver
activity	solver/SolverTypes.h	/^    float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }$/;"	f	class:Minisat::Clause
add	camlside/IA.ml	/^      method add (other: af1) = $/;"	m	class:af1
add	camlside/IA.ml	/^      method add (other: af2) = $/;"	m	class:af2
add	camlside/IA.ml	/^      method add (other: caf2) = 	$/;"	m	class:caf2
add	camlside/IA.ml	/^      method add (other: cai1) = 	$/;"	m	class:cai1
add	camlside/IA.ml	/^      method add (other: cai2) = 	$/;"	m	class:cai2
add	camlside/IA.ml	/^      method add (other: cai3) = 	$/;"	m	class:cai3
add	camlside/IA.ml	/^      method add (other: interval)= $/;"	m	class:interval
add2	camlside/IA.ml	/^      method add2 (c: float) = $/;"	m	class:af1
add2	camlside/IA.ml	/^      method add2 (c: float) = $/;"	m	class:af2
add2	camlside/IA.ml	/^      method add2 (c: float) = $/;"	m	class:caf2
add2	camlside/IA.ml	/^      method add2 (c: float) = $/;"	m	class:cai1
add2	camlside/IA.ml	/^      method add2 (c: float) = $/;"	m	class:cai2
add2	camlside/IA.ml	/^      method add2 (c: float) = $/;"	m	class:cai3
add2	camlside/IA.ml	/^      method add2 (c: float)= $/;"	m
add2	camlside/IA.ml	/^      method add2 (c: float)= $/;"	m	class:interval
addClause	solver/Solver.h	/^inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addClause	solver/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addClause	solver/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addClause	solver/Solver.h	/^inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addClause_	solver/Solver.cc	/^bool Solver::addClause_(vec<Lit>& ps)$/;"	f	class:Solver
addEmptyClause	solver/Solver.h	/^inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
add_tmp	solver/Solver.h	/^    vec<Lit>            add_tmp;$/;"	m	class:Minisat::Solver
ael	mtl/Alloc.h	/^    Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);$/;"	f	class:Minisat::RegionAllocator
ael	solver/SolverTypes.h	/^    Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }$/;"	f	class:Minisat::ClauseAllocator
af1	camlside/IA.ml	/^  class af1 size = object (self)$/;"	c
af2	camlside/IA.ml	/^  class af2 size = object (self)$/;"	c
allLog	camlside/Caml.ml	/^  let rec allLog e ia assIntv = match e with$/;"	v
allLog	solver/Caml.ml	/^  let rec allLog e ia assIntv = match e with$/;"	v
alloc	mtl/Alloc.h	/^RegionAllocator<T>::alloc(int size)$/;"	f	class:Minisat::RegionAllocator
alloc	solver/SolverTypes.h	/^    CRef alloc(const Lits& ps, bool learnt = false)$/;"	f	class:Minisat::ClauseAllocator
analyze	solver/Solver.cc	/^void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)$/;"	f	class:Solver
analyzeFinal	solver/Solver.cc	/^void Solver::analyzeFinal(Lit p, vec<Lit>& out_conflict)$/;"	f	class:Solver
analyze_stack	solver/Solver.h	/^    vec<Lit>            analyze_stack;$/;"	m	class:Minisat::Solver
analyze_toclear	solver/Solver.h	/^    vec<Lit>            analyze_toclear;$/;"	m	class:Minisat::Solver
append	mtl/Alg.h	/^static inline void append(const vec<T>& from, vec<T>& to){ copy(from, to, true); }$/;"	f	namespace:Minisat
ar	camlside/IA.ml	/^      method ar = ar$/;"	m	class:af1
ar	camlside/IA.ml	/^      method ar = ar$/;"	m	class:af2
ar	camlside/IA.ml	/^      method ar = ar$/;"	m	class:caf2
ar	camlside/IA.ml	/^      method ar = ar$/;"	m	class:cai1
ar	camlside/IA.ml	/^      method ar = ar$/;"	m	class:cai2
ar	camlside/IA.ml	/^      method ar = ar$/;"	m	class:cai3
assIntv	camlside/Caml.ml	/^      let assIntv = ci_ass lstCheck iVar lstIDLit in$/;"	v
assIntv	solver/Caml.ml	/^      let assIntv = ci_ass lstCheck iVar lstIDLit in$/;"	v
ass_decomp	camlside/Caml.ml	/^  let rec ass_decomp ass lstVarID code esl = match ass with$/;"	v
ass_decomp	solver/Caml.ml	/^  let rec ass_decomp ass lstVarID code esl = match ass with$/;"	v
ass_decomp_neg	camlside/Caml.ml	/^  let rec ass_decomp_neg ass lstVarID code esl = match ass with$/;"	v
ass_decomp_neg	solver/Caml.ml	/^  let rec ass_decomp_neg ass lstVarID code esl = match ass with$/;"	v
ass_decomp_pn	camlside/Caml.ml	/^  let rec ass_decomp_pn ass lstVarID code esl = match ass with$/;"	v
ass_decomp_pn	solver/Caml.ml	/^  let rec ass_decomp_pn ass lstVarID code esl = match ass with$/;"	v
ass_decomp_pos	camlside/Caml.ml	/^  let rec ass_decomp_pos ass lstVarID code esl = match ass with$/;"	v
ass_decomp_pos	solver/Caml.ml	/^  let rec ass_decomp_pos ass lstVarID code esl = match ass with$/;"	v
ass_decomp_test_both	camlside/Caml.ml	/^  let rec ass_decomp_test_both ass lstVarID code esl tc = match ass with$/;"	v
ass_decomp_test_both	solver/Caml.ml	/^  let rec ass_decomp_test_both ass lstVarID code esl tc = match ass with$/;"	v
ass_decomp_test_neg	camlside/Caml.ml	/^  let rec ass_decomp_test_neg ass lstVarID code esl tc = match ass with$/;"	v
ass_decomp_test_neg	solver/Caml.ml	/^  let rec ass_decomp_test_neg ass lstVarID code esl tc = match ass with$/;"	v
ass_decomp_test_pos	camlside/Caml.ml	/^  let rec ass_decomp_test_pos ass lstVarID code esl tc = match ass with$/;"	v
ass_decomp_test_pos	solver/Caml.ml	/^  let rec ass_decomp_test_pos ass lstVarID code esl tc = match ass with$/;"	v
ass_expr	camlside/Exp.ml	/^type ass_expr = $/;"	t
assigns	solver/Solver.h	/^    vec<lbool>          assigns;          \/\/ The current assignments.$/;"	m	class:Minisat::Solver
assumptions	solver/Solver.h	/^    vec<Lit>            assumptions;      \/\/ Current set of assumptions provided to solve by the user.$/;"	m	class:Minisat::Solver
assureLookahead	utils/ParseUtils.h	/^    void assureLookahead() {$/;"	f	class:Minisat::StreamBuffer
asynch_interrupt	solver/Solver.h	/^    bool                asynch_interrupt;$/;"	m	class:Minisat::Solver
attachClause	solver/Solver.cc	/^void Solver::attachClause(CRef cr) {$/;"	f	class:Solver
begin	utils/Options.h	/^    double begin;$/;"	m	struct:Minisat::DoubleRange
begin	utils/Options.h	/^    int begin;$/;"	m	struct:Minisat::IntRange
begin	utils/Options.h	/^    int64_t begin;$/;"	m	struct:Minisat::Int64Range
begin_inclusive	utils/Options.h	/^    bool  begin_inclusive;$/;"	m	struct:Minisat::DoubleRange
blocker	solver/Solver.h	/^        Lit  blocker;$/;"	m	struct:Minisat::Solver::Watcher
bool_expr	camlside/ast.ml	/^type bool_expr = $/;"	t
bool_reduce	camlside/Caml_Smt.ml	/^let rec bool_reduce = function$/;"	v
bool_simp	camlside/Caml_Smt.ml	/^let rec bool_simp = function$/;"	v
bool_simp	solver/Caml.ml	/^let rec bool_simp = function$/;"	v
bool_toList	camlside/Caml_Smt.ml	/^  let rec bool_toList e = match e with$/;"	v
bool_toList	solver/Caml.ml	/^  let rec bool_toList e = match e with$/;"	v
bool_toPrefix	camlside/Caml_Smt.ml	/^let rec bool_toPrefix = function$/;"	v
bool_toPrefix	solver/Caml.ml	/^let rec bool_toPrefix = function$/;"	v
bool_toString	camlside/Caml.ml	/^let rec bool_toString = function$/;"	v	Module:Caml
bool_toString	camlside/Caml_Smt.ml	/^let rec bool_toString = function$/;"	v
bool_toString	solver/Caml.ml	/^let rec bool_toString = function$/;"	v	Module:Caml
bool_vars	camlside/Caml.ml	/^  let rec bool_vars e = $/;"	v	Module:Caml
bool_vars	solver/Caml.ml	/^  let rec bool_vars e = $/;"	v	Module:Caml
bound	camlside/IA.ml	/^  type bound = Float of float | Neg_inf | Pos_inf$/;"	t	Module:IA
bound_step	camlside/file.h	/^double bound_step (char *filename){$/;"	f
bound_step	solver/file.h	/^double bound_step (char *filename){$/;"	f
bound_toPrefix	camlside/Caml_Smt.ml	/^let rec bound_toPrefix = function$/;"	v
bound_toPrefix	solver/Caml.ml	/^let rec bound_toPrefix = function$/;"	v
bound_var	camlside/Caml.ml	/^  let bound_var (x, it) = x ^ " = " ^ "[" ^ (string_of_float it#l) ^ "," ^ (string_of_float it#h) ^ "]"$/;"	v	Module:Caml
bound_var	solver/Caml.ml	/^  let bound_var (x, it) = x ^ " = " ^ "[" ^ (string_of_float it#l) ^ "," ^ (string_of_float it#h) ^ "]"$/;"	v	Module:Caml
bucket	mtl/Map.h	/^    const vec<Pair>& bucket(int i) const { return table[i]; }$/;"	f	class:Minisat::Map
bucket	solver/SolverTypes.h	/^    const vec<typename HashTable::Pair>& bucket(int i) const { return map.bucket(i); }$/;"	f	class:Minisat::CMap
bucket_count	mtl/Map.h	/^    int  bucket_count() const { return cap; }$/;"	f	class:Minisat::Map
bucket_count	solver/SolverTypes.h	/^    int  bucket_count() const { return map.bucket_count(); }$/;"	f	class:Minisat::CMap
budgetOff	solver/Solver.h	/^inline void     Solver::budgetOff(){ conflict_budget = propagation_budget = -1; }$/;"	f	class:Minisat::Solver
buf	mtl/Queue.h	/^    vec<T>  buf;$/;"	m	class:Minisat::Queue
buf	utils/ParseUtils.h	/^    unsigned char buf[buffer_size];$/;"	m	class:Minisat::StreamBuffer
buffer_size	utils/ParseUtils.h	/^static const int buffer_size = 1048576;$/;"	m	namespace:Minisat
build	mtl/Heap.h	/^    void build(vec<int>& ns) {$/;"	f	class:Minisat::Heap
build_ass	camlside/Caml.ml	/^  let rec build_ass eList lstVar = match eList with$/;"	v
build_ass	solver/Caml.ml	/^  let rec build_ass eList lstVar = match eList with$/;"	v
ca	solver/Solver.cc	/^    ClauseAllocator& ca;$/;"	m	struct:reduceDB_lt	file:
ca	solver/Solver.h	/^        const ClauseAllocator& ca;$/;"	m	struct:Minisat::Solver::WatcherDeleted
ca	solver/Solver.h	/^    ClauseAllocator     ca;$/;"	m	class:Minisat::Solver
caf2	camlside/IA.ml	/^  class caf2 (size: int) = object (self)$/;"	c
cai1	camlside/IA.ml	/^  class cai1 (size: int) = object (self)$/;"	c
cai2	camlside/IA.ml	/^  class cai2 (size: int) = object (self)$/;"	c
cai3	camlside/IA.ml	/^  class cai3 (size: int) = object (self)$/;"	c
calcAbstraction	solver/SolverTypes.h	/^    void calcAbstraction() {$/;"	f	class:Minisat::Clause
caml_InfCheck	camlside/modwrap.cc	/^int caml_InfCheck(char * sIntv, char* sAss){$/;"	f
caml_doTest	camlside/modwrap.cc	/^value caml_doTest (char *sIntv, char *sCons, char *sCheck, int ia){$/;"	f
caml_dynTest	camlside/modwrap.cc	/^value caml_dynTest (char *sIntv, char* dIntv, char *sCons, char *sCheck, int ia, double esl, char *sTestUS){$/;"	f
caml_genSatForm	camlside/modwrap.cc	/^value caml_genSatForm(char * sIntv, double esl)$/;"	f
caml_genSmtForm	camlside/modwrap.cc	/^value caml_genSmtForm(char * sIntv, char *sAssert, double lb, double ub)$/;"	f
caml_getNumCons	camlside/modwrap.cc	/^int caml_getNumCons(char * sAss)$/;"	f
caml_isTheoConsis	camlside/modwrap.cc	/^value caml_isTheoConsis (char *sIntv, char *sCons, char *sCheck, int ia){$/;"	f
caml_logResult	camlside/modwrap.cc	/^char* caml_logResult(char * sIntv, char *sCons, char *sCheck, int ia)$/;"	f
cancelUntil	solver/Solver.cc	/^void Solver::cancelUntil(int level) {$/;"	f	class:Solver
cap	mtl/Alloc.h	/^    uint32_t  cap;$/;"	m	class:Minisat::RegionAllocator
cap	mtl/Map.h	/^    int        cap;$/;"	m	class:Minisat::Map
cap	mtl/Vec.h	/^    int cap;$/;"	m	class:Minisat::vec
capacity	mtl/Alloc.h	/^void RegionAllocator<T>::capacity(uint32_t min_cap)$/;"	f	class:Minisat::RegionAllocator
capacity	mtl/Vec.h	/^    int      capacity (void) const     { return cap; }$/;"	f	class:Minisat::vec
capacity	mtl/Vec.h	/^void vec<T>::capacity(int min_cap) {$/;"	f	class:Minisat::vec
category	utils/Options.h	/^    const char* category;$/;"	m	class:Minisat::Option
ccmin_mode	solver/Solver.h	/^    int       ccmin_mode;         \/\/ Controls conflict clause minimization (0=none, 1=basic, 2=deep).$/;"	m	class:Minisat::Solver
checkCap	mtl/Map.h	/^    bool    checkCap(int new_size) const { return new_size > cap; }$/;"	f	class:Minisat::Map
checkGarbage	solver/Solver.h	/^inline void Solver::checkGarbage(double gf){$/;"	f	class:Minisat::Solver
checkGarbage	solver/Solver.h	/^inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }$/;"	f	class:Minisat::Solver
checkSat	camlside/Caml.ml	/^  let checkSat e ia assIntv = $/;"	v
checkSat	solver/Caml.ml	/^  let checkSat e ia assIntv = $/;"	v
checkValue	camlside/Caml.ml	/^  let checkValue e ass = $/;"	v
checkValue	solver/Caml.ml	/^  let checkValue e ass = $/;"	v
checkValue1	camlside/Caml.ml	/^  let checkValue1 e ass = $/;"	v
checkValue1	solver/Caml.ml	/^  let checkValue1 e ass = $/;"	v
checkVarID	camlside/Caml.ml	/^      let checkVarID = var_list lstCheck iVar lstIDLit in      $/;"	v
checkVarID	solver/Caml.ml	/^      let checkVarID = var_list lstCheck iVar lstIDLit in      $/;"	v
ci_ass	camlside/Caml.ml	/^  let rec ci_ass lstCheck iVar lstIDLit = match lstCheck with$/;"	v
ci_ass	solver/Caml.ml	/^  let rec ci_ass lstCheck iVar lstIDLit = match lstCheck with$/;"	v
cl	camlside/Caml.ml	/^    let (cl, sCnfCons) = genCnfCons eIntv in$/;"	v
cl	solver/Caml.ml	/^    let (cl, sCnfCons) = genCnfCons eIntv in$/;"	v
cl_count	camlside/Caml.ml	/^  let rec cl_count e = match e with $/;"	v	Module:Caml
cl_count	solver/Caml.ml	/^  let rec cl_count e = match e with $/;"	v	Module:Caml
cl_infAssign	camlside/Caml.ml	/^  let rec cl_infAssign exp = match exp with$/;"	v
cl_infAssign	solver/Caml.ml	/^  let rec cl_infAssign exp = match exp with$/;"	v
cl_toLit	camlside/Caml.ml	/^  let rec cl_toLit = function$/;"	v	Module:Caml
cl_toLit	solver/Caml.ml	/^  let rec cl_toLit = function$/;"	v	Module:Caml
claBumpActivity	solver/Solver.h	/^inline void Solver::claBumpActivity (Clause& c) {$/;"	f	class:Minisat::Solver
claDecayActivity	solver/Solver.h	/^inline void Solver::claDecayActivity() { cla_inc *= (1 \/ clause_decay); }$/;"	f	class:Minisat::Solver
cla_inc	solver/Solver.h	/^    double              cla_inc;          \/\/ Amount to bump next clause with.$/;"	m	class:Minisat::Solver
clauseWord32Size	solver/SolverTypes.h	/^    static int clauseWord32Size(int size, bool has_extra){$/;"	f	class:Minisat::ClauseAllocator
clause_decay	solver/Solver.h	/^    double    clause_decay;$/;"	m	class:Minisat::Solver
clauses	solver/Solver.h	/^    vec<CRef>           clauses;          \/\/ List of problem clauses.$/;"	m	class:Minisat::Solver
clauses_literals	solver/Solver.h	/^    uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
clean	solver/SolverTypes.h	/^void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)$/;"	f	class:Minisat::OccLists
cleanAll	solver/SolverTypes.h	/^void OccLists<Idx,Vec,Deleted>::cleanAll()$/;"	f	class:Minisat::OccLists
clear	mtl/Heap.h	/^    void clear(bool dealloc = false) $/;"	f	class:Minisat::Heap
clear	mtl/Map.h	/^    void clear  () {$/;"	f	class:Minisat::Map
clear	mtl/Queue.h	/^    void clear (bool dealloc = false) { buf.clear(dealloc); buf.growTo(1); first = end = 0; }$/;"	f	class:Minisat::Queue
clear	mtl/Vec.h	/^void vec<T>::clear(bool dealloc) {$/;"	f	class:Minisat::vec
clear	solver/SolverTypes.h	/^    void     clear       ()                           { map.clear(); }$/;"	f	class:Minisat::CMap
clear	solver/SolverTypes.h	/^    void  clear(bool free = true){$/;"	f	class:Minisat::OccLists
clearInterrupt	solver/Solver.h	/^inline void     Solver::clearInterrupt(){ asynch_interrupt = false; }$/;"	f	class:Minisat::Solver
cnf_all	camlside/Caml.ml	/^  let rec cnf_all = function 				$/;"	v	Module:Caml
cnf_all	solver/Caml.ml	/^  let rec cnf_all = function 				$/;"	v	Module:Caml
cnf_clause	camlside/Caml.ml	/^  let rec cnf_clause = function$/;"	v	Module:Caml
cnf_clause	solver/Caml.ml	/^  let rec cnf_clause = function$/;"	v	Module:Caml
cnf_list	camlside/Caml.ml	/^  let rec cnf_list a l = match l with$/;"	v	Module:Caml
cnf_list	solver/Caml.ml	/^  let rec cnf_list a l = match l with$/;"	v	Module:Caml
collect	camlside/Caml.ml	/^  let rec collect exp e = match e with$/;"	v
collect	solver/Caml.ml	/^  let rec collect exp e = match e with$/;"	v
com_list	camlside/Caml_Smt.ml	/^let rec com_list l1 l2 = match l1 with$/;"	v
com_list	solver/Caml.ml	/^let rec com_list l1 l2 = match l1 with$/;"	v
compare	camlside/Expr.ml	/^    let compare = Pervasives.compare $/;"	v	Module:MultiVar
compare_cons	camlside/Caml.ml	/^  let compare_cons e1 e2 = $/;"	v
compare_cons	solver/Caml.ml	/^  let compare_cons e1 e2 = $/;"	v
conflict	solver/Solver.h	/^    vec<Lit>   conflict;          \/\/ If problem is unsatisfiable (possibly under assumptions),$/;"	m	class:Minisat::Solver
conflict_budget	solver/Solver.h	/^    int64_t             conflict_budget;    \/\/ -1 means no budget.$/;"	m	class:Minisat::Solver
conflicts	solver/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
constant	camlside/Expr.ml	/^  let constant x = Poly.singleton [] x $/;"	v	Module:Expr
copy	mtl/Alg.h	/^static inline void copy(const T& from, T& to)$/;"	f	namespace:Minisat
copy	mtl/Alg.h	/^static inline void copy(const vec<T>& from, vec<T>& to, bool append = false)$/;"	f	namespace:Minisat
copyTo	mtl/Vec.h	/^    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }$/;"	f	class:Minisat::vec
cpuTime	utils/System.h	/^static inline double Minisat::cpuTime(void) { return (double)clock() \/ CLOCKS_PER_SEC; }$/;"	f	class:Minisat
cref	solver/Solver.h	/^        CRef cref;$/;"	m	struct:Minisat::Solver::Watcher
data	mtl/Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Minisat::Map::Pair
data	mtl/Vec.h	/^    T*  data;$/;"	m	class:Minisat::vec
data	solver/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	class:Minisat::Clause	typeref:union:Minisat::Clause::__anon2
debug	solver/SolverTypes.h	/^    void debug(){$/;"	f	class:Minisat::CMap
dec_vars	solver/Solver.h	/^    uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
decision	solver/Solver.h	/^    vec<char>           decision;         \/\/ Declares if a variable is eligible for selection in the decision heuristic.$/;"	m	class:Minisat::Solver
decisionLevel	solver/Solver.h	/^inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }$/;"	f	class:Minisat::Solver
decisions	solver/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
decomp	camlside/Caml.ml	/^  let decomp l = f4 [] l$/;"	v
decomp	solver/Caml.ml	/^  let decomp l = f4 [] l$/;"	v
decomp_reduce	camlside/Caml.ml	/^  let rec decomp_reduce ass esl = match ass with$/;"	v
decomp_reduce	solver/Caml.ml	/^  let rec decomp_reduce ass esl = match ass with$/;"	v
decrease	mtl/Heap.h	/^    void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }$/;"	f	class:Minisat::Heap
default	camlside/Expr.ml	/^  let default d = function $/;"	v	Module:Expr
deleted	solver/SolverTypes.h	/^    Deleted   deleted;$/;"	m	class:Minisat::OccLists
description	utils/Options.h	/^    const char* description;$/;"	m	class:Minisat::Option
detachClause	solver/Solver.cc	/^void Solver::detachClause(CRef cr, bool strict) {$/;"	f	class:Solver
dirties	solver/SolverTypes.h	/^    vec<Idx>  dirties;$/;"	m	class:Minisat::OccLists
dirty	solver/SolverTypes.h	/^    vec<char> dirty;$/;"	m	class:Minisat::OccLists
div_coef	camlside/Caml_Smt.ml	/^let rec div_coef exp c = match exp with$/;"	v
div_coef	solver/Caml.ml	/^let rec div_coef exp c = match exp with$/;"	v
div_constr	camlside/Caml_Smt.ml	/^let rec div_constr e = match e with$/;"	v
div_constr	solver/Caml.ml	/^let rec div_constr e = match e with$/;"	v
div_func	camlside/Caml_Smt.ml	/^let rec div_func exp l = match l with$/;"	v
div_func	solver/Caml.ml	/^let rec div_func exp l = match l with$/;"	v
div_var	camlside/Caml_Smt.ml	/^let rec div_var exp v = match exp with$/;"	v
div_var	solver/Caml.ml	/^let rec div_var exp v = match exp with$/;"	v
drand	solver/Solver.h	/^    static inline double drand(double& seed) {$/;"	f	class:Minisat::Solver
dynTest	camlside/Caml.ml	/^  let dynTest sIntv dIntv sAss strCheck ia esl strTestUS =      let olstCheck = toIntList strCheck in$/;"	v
dynTest	solver/Caml.ml	/^  let dynTest sIntv dIntv sAss strCheck ia esl strTestUS =      let olstCheck = toIntList strCheck in$/;"	v
dynamicDecom	camlside/Caml.ml	/^  let dynamicDecom assIntv dIntv lstVarID iVar uk_cl esl = $/;"	v
dynamicDecom	solver/Caml.ml	/^  let dynamicDecom assIntv dIntv lstVarID iVar uk_cl esl = $/;"	v
dynamicDecom_pos	camlside/Caml.ml	/^  let dynamicDecom_pos assIntv dIntv lstVarID iVar uk_cl esl = $/;"	v
dynamicDecom_pos	solver/Caml.ml	/^  let dynamicDecom_pos assIntv dIntv lstVarID iVar uk_cl esl = $/;"	v
dynamicDecom_test	camlside/Caml.ml	/^  let dynamicDecom_test assIntv dIntv lstVarID iVar uk_cl esl t = $/;"	v
dynamicDecom_test	solver/Caml.ml	/^  let dynamicDecom_test assIntv dIntv lstVarID iVar uk_cl esl t = $/;"	v
e3	camlside/Caml_Smt.ml	/^      let (e3, e4, s) = refor_expr e1 c in$/;"	v
e3	solver/Caml.ml	/^      let (e3, e4, s) = refor_expr e1 c in$/;"	v
e_listVar	camlside/Caml.ml	/^  let rec e_listVar e = match e with$/;"	v
e_listVar	solver/Caml.ml	/^  let rec e_listVar e = match e with$/;"	v
e_toAf1	camlside/Caml.ml	/^  let rec e_toAf1 ass id numVar = match ass with$/;"	v	Module:Caml
e_toAf1	solver/Caml.ml	/^  let rec e_toAf1 ass id numVar = match ass with$/;"	v	Module:Caml
e_toAf2	camlside/Caml.ml	/^  let rec e_toAf2 ass id numVar = match ass with$/;"	v	Module:Caml
e_toAf2	solver/Caml.ml	/^  let rec e_toAf2 ass id numVar = match ass with$/;"	v	Module:Caml
e_toCai1	camlside/Caml.ml	/^  let rec e_toCai1 ass id numVar = match ass with$/;"	v	Module:Caml
e_toCai1	solver/Caml.ml	/^  let rec e_toCai1 ass id numVar = match ass with$/;"	v	Module:Caml
e_toCai2	camlside/Caml.ml	/^  let rec e_toCai2 ass id numVar = match ass with$/;"	v	Module:Caml
e_toCai2	solver/Caml.ml	/^  let rec e_toCai2 ass id numVar = match ass with$/;"	v	Module:Caml
e_toCai3	camlside/Caml.ml	/^  let rec e_toCai3 ass id numVar = match ass with$/;"	v	Module:Caml
e_toCai3	solver/Caml.ml	/^  let rec e_toCai3 ass id numVar = match ass with$/;"	v	Module:Caml
e_toIntv	camlside/Caml.ml	/^  let rec e_toIntv exp = match exp with$/;"	v	Module:Caml
e_toIntv	solver/Caml.ml	/^  let rec e_toIntv exp = match exp with$/;"	v	Module:Caml
eagerMatch	utils/ParseUtils.h	/^static bool eagerMatch(B& in, const char* str) {$/;"	f	namespace:Minisat
elems	mtl/Map.h	/^    int  elems() const { return size; }$/;"	f	class:Minisat::Map
empty	mtl/Heap.h	/^    bool empty     ()          const { return heap.size() == 0; }$/;"	f	class:Minisat::Heap
end	mtl/Queue.h	/^    int     end;$/;"	m	class:Minisat::Queue
end	utils/Options.h	/^    double end;$/;"	m	struct:Minisat::DoubleRange
end	utils/Options.h	/^    int end;$/;"	m	struct:Minisat::IntRange
end	utils/Options.h	/^    int64_t end;$/;"	m	struct:Minisat::Int64Range
end_inclusive	utils/Options.h	/^    bool  end_inclusive;$/;"	m	struct:Minisat::DoubleRange
enqueue	solver/Solver.h	/^inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, from), true); }$/;"	f	class:Minisat::Solver
eq	camlside/IA.ml	/^  let eq a b = match a with$/;"	v
equals	mtl/Map.h	/^    E          equals;$/;"	m	class:Minisat::Map
eval	camlside/Expr.ml	/^  let rec eval (exp: Exp.smt_poly_expr) = match exp with $/;"	v	Module:Expr
eval	camlside/IA.ml	/^  let eval (a: interval) (b: interval) = $/;"	v
evalAf1	camlside/Caml.ml	/^  let rec evalAf1 ass n = function$/;"	v	Module:Caml
evalAf1	solver/Caml.ml	/^  let rec evalAf1 ass n = function$/;"	v	Module:Caml
evalAf2	camlside/Caml.ml	/^  let rec evalAf2 ass n= function$/;"	v	Module:Caml
evalAf2	solver/Caml.ml	/^  let rec evalAf2 ass n= function$/;"	v	Module:Caml
evalCI	camlside/Caml.ml	/^  let rec evalCI ass = function$/;"	v	Module:Caml
evalCI	solver/Caml.ml	/^  let rec evalCI ass = function$/;"	v	Module:Caml
evalCai1	camlside/Caml.ml	/^  let rec evalCai1 ass n= function$/;"	v	Module:Caml
evalCai1	solver/Caml.ml	/^  let rec evalCai1 ass n= function$/;"	v	Module:Caml
evalCai2	camlside/Caml.ml	/^  let rec evalCai2 ass n= function$/;"	v	Module:Caml
evalCai2	solver/Caml.ml	/^  let rec evalCai2 ass n= function$/;"	v	Module:Caml
evalCai3	camlside/Caml.ml	/^  let rec evalCai3 ass n= function$/;"	v	Module:Caml
evalCai3	solver/Caml.ml	/^  let rec evalCai3 ass n= function$/;"	v	Module:Caml
evalFloat	camlside/Caml.ml	/^  let rec evalFloat ass = function$/;"	v	Module:Caml
evalFloat	solver/Caml.ml	/^  let rec evalFloat ass = function$/;"	v	Module:Caml
evalICI	camlside/Caml.ml	/^  let rec evalICI ass = function$/;"	v	Module:Caml
evalICI	solver/Caml.ml	/^  let rec evalICI ass = function$/;"	v	Module:Caml
eval_all	camlside/Caml.ml	/^   let rec eval_all res us uk_cl e ia assIntv checkVarID= match e with$/;"	v
eval_all	solver/Caml.ml	/^   let rec eval_all res us uk_cl e ia assIntv checkVarID= match e with$/;"	v
eval_group	camlside/Caml.ml	/^  let rec eval_group ass rm rs tc = match tc with$/;"	v
eval_group	solver/Caml.ml	/^  let rec eval_group ass rm rs tc = match tc with$/;"	v
evaluate	camlside/IA.ml	/^      method evaluate =        $/;"	m
evaluate	camlside/IA.ml	/^      method evaluate =        $/;"	m	class:af1
extra_clause_field	solver/SolverTypes.h	/^    bool extra_clause_field;$/;"	m	class:Minisat::ClauseAllocator
extract	camlside/Caml.ml	/^  let rec extract lvar ltc tc = match tc with$/;"	v
extract	solver/Caml.ml	/^  let rec extract lvar ltc tc = match tc with$/;"	v
f	camlside/Caml.ml	/^  let rec f r l1 l2 = match l2 with$/;"	v
f	camlside/Expr.ml	/^        let f va co acc = $/;"	v
f	solver/Caml.ml	/^  let rec f r l1 l2 = match l2 with$/;"	v
f1	camlside/Caml.ml	/^  let rec f1 r l a = match l with$/;"	v
f1	solver/Caml.ml	/^  let rec f1 r l a = match l with$/;"	v
f2	camlside/Caml.ml	/^  let rec f2 r l a = match l with$/;"	v
f2	solver/Caml.ml	/^  let rec f2 r l a = match l with$/;"	v
f22	camlside/Caml.ml	/^  let rec f22 r l a = match l with$/;"	v
f22	solver/Caml.ml	/^  let rec f22 r l a = match l with$/;"	v
f3	camlside/Caml.ml	/^  let rec f3 r l1 l2 = match l2 with$/;"	v
f3	solver/Caml.ml	/^  let rec f3 r l1 l2 = match l2 with$/;"	v
f33	camlside/Caml.ml	/^  let rec f33 r l1 l2 = match l2 with$/;"	v
f33	solver/Caml.ml	/^  let rec f33 r l1 l2 = match l2 with$/;"	v
f4	camlside/Caml.ml	/^  let rec f4 r l = match l with$/;"	v
f4	solver/Caml.ml	/^  let rec f4 r l = match l with$/;"	v
f44	camlside/Caml.ml	/^  let rec f44 r l = match l with$/;"	v
f44	solver/Caml.ml	/^  let rec f44 r l = match l with$/;"	v
f_infAssign	camlside/Caml.ml	/^  let rec f_infAssign exp = match exp with$/;"	v
f_infAssign	solver/Caml.ml	/^  let rec f_infAssign exp = match exp with$/;"	v
f_listVar	camlside/Caml.ml	/^  let rec f_listVar e = match e with$/;"	v
f_listVar	solver/Caml.ml	/^  let rec f_listVar e = match e with$/;"	v
f_toList	camlside/Caml.ml	/^  let rec f_toList e = match e with$/;"	v
f_toList	solver/Caml.ml	/^  let rec f_toList e = match e with$/;"	v
f_toLit	camlside/Caml.ml	/^  let rec f_toLit = function $/;"	v	Module:Caml
f_toLit	solver/Caml.ml	/^  let rec f_toLit = function $/;"	v	Module:Caml
find	mtl/Alg.h	/^static inline bool find(V& ts, const T& t)$/;"	f	namespace:Minisat
find_join_clause	camlside/Caml.ml	/^    let rec find_join_clause  e lstVar lstConstr = match lstConstr with$/;"	v
find_join_clause	solver/Caml.ml	/^    let rec find_join_clause  e lstVar lstConstr = match lstConstr with$/;"	v
find_tc	camlside/Caml.ml	/^  let find_tc lvars oAss e uAss = $/;"	v
find_tc	solver/Caml.ml	/^  let find_tc lvars oAss e uAss = $/;"	v
first	mtl/Queue.h	/^    int     first;$/;"	m	class:Minisat::Queue
first_list	camlside/Caml.ml	/^      let first_list = List.append sub [first_cons] in$/;"	v
first_list	solver/Caml.ml	/^      let first_list = List.append sub [first_cons] in$/;"	v
first_search	camlside/Caml.ml	/^  let rec first_search lvars oAss uAss first_list = match first_list with$/;"	v
first_search	solver/Caml.ml	/^  let rec first_search lvars oAss uAss first_list = match first_list with$/;"	v
first_word	camlside/file.h	/^string first_word (string s){$/;"	f
first_word	solver/file.h	/^string first_word (string s){$/;"	f
formula	camlside/ast.ml	/^type formula =$/;"	t
free	mtl/Alloc.h	/^    void     free      (int size)    { wasted_ += size; }$/;"	f	class:Minisat::RegionAllocator
free	solver/SolverTypes.h	/^    void free(CRef cid)$/;"	f	class:Minisat::ClauseAllocator
ftemp	camlside/Caml.ml	/^   let rec ftemp = function$/;"	v
ftemp	solver/Caml.ml	/^   let rec ftemp = function$/;"	v
garbageCollect	solver/Solver.cc	/^void Solver::garbageCollect()$/;"	f	class:Solver
garbage_frac	solver/Solver.h	/^    double    garbage_frac;       \/\/ The fraction of wasted memory allowed before a garbage collection is triggered.$/;"	m	class:Minisat::Solver
ge	camlside/IA.ml	/^  let ge a b = match a with$/;"	v
genAss_test	camlside/Caml.ml	/^  let rec genAss_test r g ass esl = match ass with$/;"	v
genAss_test	solver/Caml.ml	/^  let rec genAss_test r g ass esl = match ass with$/;"	v
genCnfCons	camlside/Caml.ml	/^    let rec genCnfCons = function$/;"	v
genCnfCons	solver/Caml.ml	/^    let rec genCnfCons = function$/;"	v
genSatForm	camlside/Caml.ml	/^  let genSatForm sIntv esl = $/;"	v
genSatForm	solver/Caml.ml	/^  let genSatForm sIntv esl = $/;"	v
genSmtForm	camlside/Caml_Smt.ml	/^let genSmtForm sIntv sAssert loBound upBound =       $/;"	v
genSmtForm	solver/Caml.ml	/^let genSmtForm sIntv sAssert loBound upBound =       $/;"	v
gen_constr	camlside/file.h	/^string gen_constr (string s){$/;"	f
gen_constr	solver/file.h	/^string gen_constr (string s){$/;"	f
gen_ftest	camlside/Caml.ml	/^  let rec gen_ftest l1 l2 assIntv = match assIntv with$/;"	v
gen_ftest	solver/Caml.ml	/^  let rec gen_ftest l1 l2 assIntv = match assIntv with$/;"	v
gen_intv	camlside/Caml_Smt.ml	/^let rec gen_intv e mb bst bCons= match e with$/;"	v
gen_intv	camlside/file.h	/^ string gen_intv (string s){$/;"	f
gen_intv	solver/Caml.ml	/^let rec gen_intv e mb bst bCons= match e with$/;"	v
gen_intv	solver/file.h	/^ string gen_intv (string s){$/;"	f
gen_string	camlside/Caml_Smt.ml	/^let gen_string (v, l1, u1, bst, bCons) = $/;"	v
gen_string	solver/Caml.ml	/^let gen_string (v, l1, u1, bst, bCons) = $/;"	v
gen_test2	camlside/Caml.ml	/^  let gen_test2 x lb ub = $/;"	v
gen_test2	solver/Caml.ml	/^  let gen_test2 x lb ub = $/;"	v
gen_test21	camlside/Caml.ml	/^  let gen_test21 x lb ub esl = $/;"	v
gen_test21	solver/Caml.ml	/^  let gen_test21 x lb ub esl = $/;"	v
gen_test22	camlside/Caml.ml	/^  let gen_test22 x lb ub = [(x, lb); (x, ub)]$/;"	v
gen_test22	solver/Caml.ml	/^  let gen_test22 x lb ub = [(x, lb); (x, ub)]$/;"	v
gen_test3	camlside/Caml.ml	/^  let gen_test3 x lb ub = $/;"	v
gen_test3	solver/Caml.ml	/^  let gen_test3 x lb ub = $/;"	v
gen_test31	camlside/Caml.ml	/^  let gen_test31 x lb ub = $/;"	v
gen_test31	solver/Caml.ml	/^  let gen_test31 x lb ub = $/;"	v
gen_test4	camlside/Caml.ml	/^  let gen_test4 x lb ub = $/;"	v
gen_test4	solver/Caml.ml	/^  let gen_test4 x lb ub = $/;"	v
gen_test_semi3	camlside/Caml.ml	/^  let gen_test_semi3 x lb ub = $/;"	v
gen_test_semi3	solver/Caml.ml	/^  let gen_test_semi3 x lb ub = $/;"	v
gen_test_tick	camlside/Caml.ml	/^  let gen_test_tick x lb ub esl = $/;"	v
gen_test_tick	solver/Caml.ml	/^  let gen_test_tick x lb ub esl = $/;"	v
geq	camlside/IA.ml	/^  let geq a b = match a with$/;"	v
getAss_expr	camlside/Caml_Smt.ml	/^let rec getAss_expr = function$/;"	v	Module:Caml
getAss_expr	solver/Caml.ml	/^let rec getAss_expr = function$/;"	v
getAssert	camlside/file.h	/^string getAssert (char *filename){$/;"	f
getAssert	solver/file.h	/^string getAssert (char *filename){$/;"	f
getBound	camlside/Caml_Smt.ml	/^let rec getBound (e: smt_bool_expr) = match e with $/;"	v
getBound	solver/Caml.ml	/^let rec getBound (e: bool_expr) = match e with $/;"	v
getHelpPrefixString	utils/Options.h	/^    static const char*&  getHelpPrefixString() { static const char* help_prefix_str = ""; return help_prefix_str; }$/;"	f	class:Minisat::Option
getIA	camlside/file.h	/^int getIA (char *argIA){$/;"	f
getIA	solver/file.h	/^int getIA (char *argIA){$/;"	f
getIntv	camlside/file.h	/^string getIntv (char *filename){$/;"	f
getIntv	solver/file.h	/^string getIntv (char *filename){$/;"	f
getLU	camlside/Caml.ml	/^   let getLU lit = match lit with$/;"	v
getLU	solver/Caml.ml	/^   let getLU lit = match lit with$/;"	v
getLit	solver/file.h	/^int* getLit (string cl){$/;"	f
getLoBound	solver/file.h	/^double getLoBound (char* bound){$/;"	f
getMB	camlside/Caml.ml	/^  let rec getMB m constr = match constr with$/;"	v	Module:Caml
getMB	solver/Caml.ml	/^  let rec getMB m constr = match constr with$/;"	v	Module:Caml
getMaxBound	camlside/Caml.ml	/^  let rec getMaxBound m cl = match cl with$/;"	v	Module:Caml
getMaxBound	solver/Caml.ml	/^  let rec getMaxBound m cl = match cl with$/;"	v	Module:Caml
getNumCons	camlside/Caml.ml	/^  let getNumCons sAss =$/;"	v
getNumCons	solver/Caml.ml	/^  let getNumCons sAss =$/;"	v
getOptionList	utils/Options.h	/^    static vec<Option*>& getOptionList () { static vec<Option*> options; return options; }$/;"	f	class:Minisat::Option
getPositive	camlside/Caml.ml	/^  let rec getPositive l iVar = match l with$/;"	v
getPositive	solver/Caml.ml	/^  let rec getPositive l iVar = match l with$/;"	v
getSearchingBox	solver/file.h	/^double getSearchingBox (char *sBox){$/;"	f
getTimeout	solver/file.h	/^double getTimeout (char *tout){$/;"	f
getUpBound	solver/file.h	/^double getUpBound (char* bound){$/;"	f
getUsageString	utils/Options.h	/^    static const char*&  getUsageString() { static const char* usage_str; return usage_str; }$/;"	f	class:Minisat::Option
getVar	camlside/Caml.ml	/^  let getVar = function$/;"	v	Module:Caml
getVar	solver/Caml.ml	/^  let getVar = function$/;"	v	Module:Caml
get_assert	solver/file.h	/^string get_assert (string s){$/;"	f
get_bExpr	camlside/Caml_Smt.ml	/^let rec get_bExpr e = match e with$/;"	v
get_bExpr	solver/Caml.ml	/^let rec get_bExpr e = match e with$/;"	v
get_bs	camlside/file.h	/^string get_bs (string s){$/;"	f
get_bs	solver/file.h	/^string get_bs (string s){$/;"	f
get_cons	camlside/file.h	/^string get_cons (char *filename, int nvar){$/;"	f
get_cons	solver/file.h	/^string get_cons (char *filename, int nvar){$/;"	f
get_dep	camlside/Caml.ml	/^  let rec get_dep n lst_vars lst = match lst with$/;"	v
get_dep	solver/Caml.ml	/^  let rec get_dep n lst_vars lst = match lst with$/;"	v
get_index	camlside/Caml.ml	/^  let rec get_index x ass = match ass with$/;"	v
get_index	solver/Caml.ml	/^  let rec get_index x ass = match ass with$/;"	v
get_index_all	camlside/Caml.ml	/^  let rec get_index_all r varlist ass = match varlist with$/;"	v
get_index_all	solver/Caml.ml	/^  let rec get_index_all r varlist ass = match varlist with$/;"	v
get_lbound	camlside/file.h	/^string get_lbound (string s){$/;"	f
get_lbound	solver/file.h	/^string get_lbound (string s){$/;"	f
get_listvars	solver/file.h	/^string get_listvars (char *filename, int nvar, double lb){$/;"	f
get_maxdep	camlside/Caml.ml	/^  let rec get_maxdep res maxdep olst lst = match lst with$/;"	v
get_maxdep	solver/Caml.ml	/^  let rec get_maxdep res maxdep olst lst = match lst with$/;"	v
get_mb	camlside/file.h	/^string get_mb (string s){$/;"	f
get_mb	solver/file.h	/^string get_mb (string s){$/;"	f
get_minimal	camlside/Caml.ml	/^  let rec get_minimal res lst = match lst with$/;"	v
get_minimal	solver/Caml.ml	/^  let rec get_minimal res lst = match lst with$/;"	v
get_namevar	solver/file.h	/^string get_namevar (string s){$/;"	f
get_pn	camlside/Caml.ml	/^  let rec get_pn sign e = match e with$/;"	v
get_pn	solver/Caml.ml	/^  let rec get_pn sign e = match e with$/;"	v
get_pos_neg	camlside/Caml.ml	/^  let rec get_pos_neg (pos, neg) sign e = match e with$/;"	v
get_pos_neg	solver/Caml.ml	/^  let rec get_pos_neg (pos, neg) sign e = match e with$/;"	v
get_sign	camlside/Caml.ml	/^  let rec get_sign sign e = match e with$/;"	v
get_sign	solver/Caml.ml	/^  let rec get_sign sign e = match e with$/;"	v
get_ubound	camlside/file.h	/^string get_ubound (string s){$/;"	f
get_ubound	solver/file.h	/^string get_ubound (string s){$/;"	f
get_unsatcore	camlside/Caml.ml	/^  let get_unsatcore f ia assIntv =$/;"	v
get_unsatcore	solver/Caml.ml	/^  let get_unsatcore f ia assIntv =$/;"	v
get_var	camlside/file.h	/^string get_var (string sIn){$/;"	f
get_var	solver/file.h	/^string get_var (string sIn){$/;"	f
get_vars	camlside/Caml.ml	/^  let rec get_vars = function$/;"	v	Module:Caml
get_vars	camlside/Caml_Smt.ml	/^  let rec get_vars = function$/;"	v
get_vars	solver/Caml.ml	/^  let rec get_vars = function$/;"	v	Module:Caml
group_cons	camlside/Caml.ml	/^  let group_cons listAss listVar = $/;"	v
group_cons	solver/Caml.ml	/^  let group_cons listAss listVar = $/;"	v
growTo	mtl/Vec.h	/^void vec<T>::growTo(int size) {$/;"	f	class:Minisat::vec
growTo	mtl/Vec.h	/^void vec<T>::growTo(int size, const T& pad) {$/;"	f	class:Minisat::vec
growTo	solver/SolverTypes.h	/^    void     growTo      (CRef cr, const T& t){ map.insert(cr, t); } \/\/ NOTE: for compatibility$/;"	f	class:Minisat::CMap
h	camlside/IA.ml	/^      method h = h$/;"	m	class:interval
has	mtl/Map.h	/^    bool has   (const K& k) const {$/;"	f	class:Minisat::Map
has	solver/SolverTypes.h	/^    bool     has         (CRef cr, T& t)      { return map.peek(cr, t); }$/;"	f	class:Minisat::CMap
has_extra	solver/SolverTypes.h	/^        unsigned has_extra : 1;$/;"	m	struct:Minisat::Clause::__anon1
has_extra	solver/SolverTypes.h	/^    bool         has_extra   ()      const   { return header.has_extra; }$/;"	f	class:Minisat::Clause
hash	mtl/Map.h	/^    H          hash;$/;"	m	class:Minisat::Map
hash	mtl/Map.h	/^static inline uint32_t hash(int32_t x) { return (uint32_t)x; }$/;"	f	namespace:Minisat
hash	mtl/Map.h	/^static inline uint32_t hash(int64_t x) { return (uint32_t)x; }$/;"	f	namespace:Minisat
hash	mtl/Map.h	/^static inline uint32_t hash(uint32_t x){ return x; }$/;"	f	namespace:Minisat
hash	mtl/Map.h	/^static inline uint32_t hash(uint64_t x){ return (uint32_t)x; }$/;"	f	namespace:Minisat
header	solver/SolverTypes.h	/^        unsigned size      : 27; }                            header;$/;"	m	class:Minisat::Clause	typeref:struct:Minisat::Clause::__anon1
heap	mtl/Heap.h	/^    vec<int> heap;     \/\/ Heap of integers$/;"	m	class:Minisat::Heap
help	utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::BoolOption
help	utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::DoubleOption
help	utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::Int64Option
help	utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::IntOption
help	utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::StringOption
iVar	camlside/Caml.ml	/^      let iVar = (List.length lstLit) + (List.length dlstLit) in$/;"	v
iVar	solver/Caml.ml	/^      let iVar = (List.length lstLit) + (List.length dlstLit) in$/;"	v
idx	camlside/Caml.ml	/^  let rec idx n = match n with$/;"	v	Module:Caml
idx	solver/Caml.ml	/^  let rec idx n = match n with$/;"	v	Module:Caml
imax	mtl/Vec.h	/^    static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }$/;"	f	class:Minisat::vec
in	utils/ParseUtils.h	/^    gzFile        in;$/;"	m	class:Minisat::StreamBuffer
inHeap	mtl/Heap.h	/^    bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }$/;"	f	class:Minisat::Heap
in_expr	camlside/Caml_Smt.ml	/^let rec in_expr e v = match e with$/;"	v
in_expr	solver/Caml.ml	/^let rec in_expr e v = match e with$/;"	v
in_list	camlside/Caml_Smt.ml	/^let rec in_list l a = match l with$/;"	v
in_list	solver/Caml.ml	/^let rec in_list l a = match l with$/;"	v
incClause	camlside/file.h	/^string incClause (string s){$/;"	f
incClause	solver/file.h	/^string incClause (string s){$/;"	f
increase	mtl/Heap.h	/^    void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }$/;"	f	class:Minisat::Heap
index	mtl/Map.h	/^    int32_t index  (const K& k) const { return hash(k) % cap; }$/;"	f	class:Minisat::Map
indices	mtl/Heap.h	/^    vec<int> indices;  \/\/ Each integers position (index) in the Heap$/;"	m	class:Minisat::Heap
infCheck	camlside/Caml.ml	/^  let infCheck sIntv sAss = $/;"	v
infCheck	solver/Caml.ml	/^  let infCheck sIntv sAss = $/;"	v
inf_checkSat	camlside/Caml.ml	/^  let inf_checkSat e assIntv = $/;"	v
inf_checkSat	solver/Caml.ml	/^  let inf_checkSat e assIntv = $/;"	v
inf_eval_all	camlside/Caml.ml	/^   let rec inf_eval_all e assIntv = match e with$/;"	v
inf_eval_all	solver/Caml.ml	/^   let rec inf_eval_all e assIntv = match e with$/;"	v
inf_max	camlside/IA.ml	/^  let inf_max a b = $/;"	v
inf_min	camlside/IA.ml	/^  let inf_min a b = $/;"	v
init	solver/SolverTypes.h	/^    void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }$/;"	f	class:Minisat::OccLists
insert	mtl/Heap.h	/^    void insert(int n)$/;"	f	class:Minisat::Heap
insert	mtl/Map.h	/^    void insert (const K& k, const D& d) { if (checkCap(size+1)) rehash(); _insert(k, d); size++; }$/;"	f	class:Minisat::Map
insert	mtl/Queue.h	/^    void insert(T elem) {   \/\/ INVARIANT: buf[end] is always unused$/;"	f	class:Minisat::Queue
insert	solver/SolverTypes.h	/^    void     insert      (CRef cr, const T& t){ map.insert(cr, t); }$/;"	f	class:Minisat::CMap
insertVarOrder	solver/Solver.h	/^inline void Solver::insertVarOrder(Var x) {$/;"	f	class:Minisat::Solver
interrupt	solver/Solver.h	/^inline void     Solver::interrupt(){ asynch_interrupt = true; }$/;"	f	class:Minisat::Solver
interval	camlside/IA.ml	/^  class interval lo hi = object (self)$/;"	c
intv_clause	camlside/ast.ml	/^type intv_clause =                         (*interval constraint for each variable*)$/;"	t
intv_expr	camlside/ast.ml	/^type intv_expr = $/;"	t
intv_var	camlside/file.h	/^string intv_var (string s){$/;"	f
intv_var	solver/file.h	/^string intv_var (string s){$/;"	f
irand	solver/Solver.h	/^    static inline int irand(double& seed, int size) {$/;"	f	class:Minisat::Solver
isChildLit	camlside/Caml.ml	/^   let isChildLit lit1 lit2 = (*lit2 is a child literal of lit1*)$/;"	v
isChildLit	solver/Caml.ml	/^   let isChildLit lit1 lit2 = (*lit2 is a child literal of lit1*)$/;"	v
isEof	utils/ParseUtils.h	/^static inline bool isEof(StreamBuffer& in) { return *in == EOF;  }$/;"	f	namespace:Minisat
isEof	utils/ParseUtils.h	/^static inline bool isEof(const char*   in) { return *in == '\\0'; }$/;"	f	namespace:Minisat
isReachBound	camlside/Caml.ml	/^  let rec isReachBound ass esl = match ass with$/;"	v
isReachBound	solver/Caml.ml	/^  let rec isReachBound ass esl = match ass with$/;"	v
isTheoConsis	camlside/Caml.ml	/^  let isTheoConsis sIntv sAss strCheck ia =$/;"	v
isTheoConsis	solver/Caml.ml	/^  let isTheoConsis sIntv sAss strCheck ia =$/;"	v
isUnsat	camlside/Caml.ml	/^  let isUnsat fpos neg ia assIntv =$/;"	v
isUnsat	solver/Caml.ml	/^  let isUnsat fpos neg ia assIntv =$/;"	v
isVar	camlside/Caml.ml	/^  let isVar = function$/;"	v	Module:Caml
isVar	camlside/Caml_Smt.ml	/^let isVar = function$/;"	v	Module:Caml
isVar	solver/Caml.ml	/^  let isVar = function$/;"	v	Module:Caml
isVar	solver/Caml.ml	/^let isVar = function$/;"	v
is_minimal	camlside/Caml.ml	/^  let rec is_minimal l lst = match lst with$/;"	v
is_minimal	solver/Caml.ml	/^  let rec is_minimal l lst = match lst with$/;"	v
is_sat	camlside/Caml.ml	/^  let rec is_sat e ass = match e with$/;"	v
is_sat	solver/Caml.ml	/^  let rec is_sat e ass = match e with$/;"	v
is_unsat	camlside/Caml.ml	/^  let rec is_unsat lstTest = match lstTest with$/;"	v
is_unsat	solver/Caml.ml	/^  let rec is_unsat lstTest = match lstTest with$/;"	v
k	camlside/IA.ml	/^      method k = k$/;"	m	class:af1
k	camlside/IA.ml	/^      method k = k$/;"	m	class:af2
k	camlside/IA.ml	/^      method k = k$/;"	m	class:caf2
k	camlside/IA.ml	/^      method k = k$/;"	m	class:cai1
k	camlside/IA.ml	/^      method k = k$/;"	m	class:cai2
k	camlside/IA.ml	/^      method k = k$/;"	m	class:cai3
key	mtl/Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Minisat::Map::Pair
keyAssert	camlside/file.h	/^const string keyAssert = "assert";$/;"	v
keyAssert	solver/file.h	/^const string keyAssert = "assert";$/;"	v
keyVar	camlside/file.h	/^const string keyVar = "declare-var";$/;"	v
keyVar	solver/file.h	/^const string keyVar    = "declare-var";$/;"	v
kn	camlside/IA.ml	/^      method kn = kn$/;"	m	class:af2
kp	camlside/IA.ml	/^      method kp = kp$/;"	m	class:af2
l	camlside/IA.ml	/^      method l = l$/;"	m	class:interval
l	camlside/IA.ml	/^      val mutable l = (lo: float)$/;"	v	class:interval
l1	camlside/Caml_Smt.ml	/^  | Add (e1, e2) -> let (l1, a1) = _lstVar e1 in$/;"	v
l1	camlside/Caml_Smt.ml	/^  | Sub (e1, e2) -> let (l1, a1) = _lstVar e1 in$/;"	v
l1	solver/Caml.ml	/^  | Add (e1, e2) -> let (l1, a1) = _lstVar e1 in$/;"	v
l1	solver/Caml.ml	/^  | Sub (e1, e2) -> let (l1, a1) = _lstVar e1 in$/;"	v
l2	camlside/Caml_Smt.ml	/^                    let (l2, a2) = _lstVar e2 in$/;"	v
l2	solver/Caml.ml	/^                    let (l2, a2) = _lstVar e2 in$/;"	v
l_False	solver/SolverTypes.h	/^#define l_False /;"	d
l_True	solver/SolverTypes.h	/^#define l_True /;"	d
l_Undef	solver/SolverTypes.h	/^#define l_Undef /;"	d
last	mtl/Vec.h	/^    T&       last  (void)              { return data[sz-1]; }$/;"	f	class:Minisat::vec
last	mtl/Vec.h	/^    const T& last  (void) const        { return data[sz-1]; }$/;"	f	class:Minisat::vec
last	solver/SolverTypes.h	/^    const Lit&   last        ()      const   { return data[header.size-1].lit; }$/;"	f	class:Minisat::Clause
last_word	solver/file.h	/^string last_word (string s){$/;"	f
lbool	solver/SolverTypes.h	/^    explicit lbool(bool x) : value(!x) { }$/;"	f	class:Minisat::lbool
lbool	solver/SolverTypes.h	/^    explicit lbool(uint8_t v) : value(v) { }$/;"	f	class:Minisat::lbool
lbool	solver/SolverTypes.h	/^    lbool()       : value(0) { }$/;"	f	class:Minisat::lbool
lbool	solver/SolverTypes.h	/^class lbool {$/;"	c	namespace:Minisat
le	camlside/IA.ml	/^  let le a b = match a with$/;"	v
lea	mtl/Alloc.h	/^    T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }$/;"	f	class:Minisat::RegionAllocator
lea	mtl/Alloc.h	/^    const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }$/;"	f	class:Minisat::RegionAllocator
lea	solver/SolverTypes.h	/^    Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }$/;"	f	class:Minisat::ClauseAllocator
lea	solver/SolverTypes.h	/^    const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }$/;"	f	class:Minisat::ClauseAllocator
learnt	solver/SolverTypes.h	/^        unsigned learnt    : 1;$/;"	m	struct:Minisat::Clause::__anon1
learnt	solver/SolverTypes.h	/^    bool         learnt      ()      const   { return header.learnt; }$/;"	f	class:Minisat::Clause
learnts	solver/Solver.h	/^    vec<CRef>           learnts;          \/\/ List of learnt clauses.$/;"	m	class:Minisat::Solver
learnts_literals	solver/Solver.h	/^    uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
learntsize_adjust_cnt	solver/Solver.h	/^    int                 learntsize_adjust_cnt;$/;"	m	class:Minisat::Solver
learntsize_adjust_confl	solver/Solver.h	/^    double              learntsize_adjust_confl;$/;"	m	class:Minisat::Solver
learntsize_adjust_inc	solver/Solver.h	/^    double    learntsize_adjust_inc;$/;"	m	class:Minisat::Solver
learntsize_adjust_start_confl	solver/Solver.h	/^    int       learntsize_adjust_start_confl;$/;"	m	class:Minisat::Solver
learntsize_factor	solver/Solver.h	/^    double    learntsize_factor;  \/\/ The intitial limit for learnt clauses is a factor of the original clauses.                (default 1 \/ 3)$/;"	m	class:Minisat::Solver
learntsize_inc	solver/Solver.h	/^    double    learntsize_inc;     \/\/ The limit for learnt clauses is multiplied with this factor each restart.                 (default 1.1)$/;"	m	class:Minisat::Solver
left	mtl/Heap.h	/^    static inline int left  (int i) { return i*2+1; }$/;"	f	class:Minisat::Heap
leftExp	camlside/Caml.ml	/^  let leftExp = function$/;"	v	Module:Caml
leftExp	solver/Caml.ml	/^  let leftExp = function$/;"	v	Module:Caml
length_cons	camlside/Caml.ml	/^  let length_cons e = List.length (red_list (bool_vars e))$/;"	v
length_cons	solver/Caml.ml	/^  let length_cons e = List.length (red_list (bool_vars e))$/;"	v
leq	camlside/IA.ml	/^  let leq a b = match a with$/;"	v
let_expr	camlside/Exp.ml	/^type let_expr = $/;"	t
level	solver/Solver.h	/^    struct VarData { CRef reason; int level; };$/;"	m	struct:Minisat::Solver::VarData
level	solver/Solver.h	/^inline int  Solver::level (Var x) const { return vardata[x].level; }$/;"	f	class:Minisat::Solver
lex	camlside/SmtLexer.ml	/^let rec lex lexbuf =$/;"	v
lex	camlside/lexer.ml	/^let rec lex lexbuf =$/;"	v
list_IDtoLit	camlside/Caml.ml	/^   let rec list_IDtoLit l lstIDLit = match l with$/;"	v
list_IDtoLit	solver/Caml.ml	/^   let rec list_IDtoLit l lstIDLit = match l with$/;"	v
list_LittoID	camlside/Caml.ml	/^   let rec list_LittoID l lstLitID = match l with$/;"	v
list_LittoID	solver/Caml.ml	/^   let rec list_LittoID l lstLitID = match l with$/;"	v
list_group	camlside/Caml.ml	/^  let rec list_group r l = match l with$/;"	v
list_group	solver/Caml.ml	/^  let rec list_group r l = match l with$/;"	v
list_remove	camlside/Caml_Smt.ml	/^  let list_remove element lst = List.filter (fun x-> x <> element) lst$/;"	v
list_remove	solver/Caml.ml	/^  let list_remove element lst = List.filter (fun x-> x <> element) lst$/;"	v
list_toBool	camlside/Caml_Smt.ml	/^  let rec list_toBool lst = match lst with$/;"	v
list_toBool	solver/Caml.ml	/^  let rec list_toBool lst = match lst with$/;"	v
list_unsat	camlside/Caml.ml	/^    let rec list_unsat e ass= match e with$/;"	v
list_unsat	camlside/Caml.ml	/^  let rec list_unsat l e ass= match e with$/;"	v
list_unsat	solver/Caml.ml	/^    let rec list_unsat e ass= match e with$/;"	v
list_unsat	solver/Caml.ml	/^  let rec list_unsat l e ass= match e with$/;"	v
lit	solver/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon2
litRedundant	solver/Solver.cc	/^bool Solver::litRedundant(Lit p, uint32_t abstract_levels)$/;"	f	class:Solver
lit_Error	solver/SolverTypes.h	/^const Lit lit_Error = { -1 };  \/\/ }$/;"	m	namespace:Minisat
lit_Undef	solver/SolverTypes.h	/^const Lit lit_Undef = { -2 };  \/\/ }- Useful special constants.$/;"	m	namespace:Minisat
locked	solver/Solver.h	/^inline bool     Solver::locked          (const Clause& c) const { return value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c; }$/;"	f	class:Minisat::Solver
logResult	camlside/Caml.ml	/^  let logResult sIntv sAss strCheck ia =$/;"	v
logResult	solver/Caml.ml	/^  let logResult sIntv sAss strCheck ia =$/;"	v
logSat	camlside/Caml.ml	/^  let logSat e ia assIntv = $/;"	v
logSat	solver/Caml.ml	/^  let logSat e ia assIntv = $/;"	v
logTest	camlside/Caml.ml	/^  let logTest assIntv ass all_cl uk_cl ia = $/;"	v
logTest	solver/Caml.ml	/^  let logTest assIntv ass all_cl uk_cl ia = $/;"	v
logTestCase	camlside/Caml.ml	/^  let rec logTestCase ass = match ass with$/;"	v
logTestCase	solver/Caml.ml	/^  let rec logTestCase ass = match ass with$/;"	v
logValue	camlside/Caml.ml	/^  let logValue e ass = $/;"	v
logValue	solver/Caml.ml	/^  let logValue e ass = $/;"	v
logValue_all	camlside/Caml.ml	/^    let rec logValue_all e ass = match e with$/;"	v
logValue_all	solver/Caml.ml	/^    let rec logValue_all e ass = match e with$/;"	v
lookup	solver/SolverTypes.h	/^    Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }$/;"	f	class:Minisat::OccLists
lst	camlside/Caml.ml	/^      let lst = idx iVar in $/;"	v
lst	solver/Caml.ml	/^      let lst = idx iVar in $/;"	v
lstBVar	camlside/Caml_Smt.ml	/^let rec lstBVar = function$/;"	v	Module:Caml
lstBVar	solver/Caml.ml	/^let rec lstBVar = function$/;"	v
lstCheck	camlside/Caml.ml	/^      let lstCheck = redLstCheck [] positiveCheck lstIDLit in$/;"	v
lstCheck	solver/Caml.ml	/^      let lstCheck = redLstCheck [] positiveCheck lstIDLit in$/;"	v
lstIDLit	camlside/Caml.ml	/^      let lstIDLit = List.combine lst (List.append lstLit dlstLit) in$/;"	v
lstIDLit	solver/Caml.ml	/^      let lstIDLit = List.combine lst (List.append lstLit dlstLit) in$/;"	v
lstSubVar	camlside/Caml_Smt.ml	/^let rec lstSubVar = function$/;"	v	Module:Caml
lstSubVar	solver/Caml.ml	/^let rec lstSubVar = function$/;"	v
lstVars	camlside/Caml.ml	/^  let lstVars lst = $/;"	v
lstVars	solver/Caml.ml	/^  let lstVars lst = $/;"	v
lt	mtl/Heap.h	/^    Comp     lt;       \/\/ The heap is a minimum-heap with respect to this comparator$/;"	m	class:Minisat::Heap
luby	solver/Solver.cc	/^static double luby(double y, int x){$/;"	f	file:
luby_restart	solver/Solver.h	/^    bool      luby_restart;$/;"	m	class:Minisat::Solver
m	camlside/IA.ml	/^      method m = m$/;"	m	class:cai3
m1	camlside/IA.ml	/^      method m1 = m1$/;"	m	class:cai2
m2	camlside/IA.ml	/^      method m2 = m2$/;"	m	class:cai2
m3	camlside/IA.ml	/^      method m3 = m3$/;"	m	class:cai2
main	camlside/SmtParser.mli	/^val main :$/;"	v
main	camlside/main.cc	/^int main(int argc, char** argv)$/;"	f
main	camlside/parser.mli	/^val main :$/;"	v
main	solver/Main.cc	/^int main(int argc, char** argv)$/;"	f
make_lstIntv	camlside/Caml_Smt.ml	/^  let rec make_lstIntv eIntv ub = match eIntv with$/;"	v
make_lstIntv	solver/Caml.ml	/^  let rec make_lstIntv eIntv ub = match eIntv with$/;"	v
map	solver/SolverTypes.h	/^    HashTable map;$/;"	m	class:Minisat::CMap
mapVar	solver/Solver.cc	/^static Var mapVar(Var x, vec<Var>& map, Var& max)$/;"	f	file:
mark	solver/SolverTypes.h	/^        unsigned mark      : 2;$/;"	m	struct:Minisat::Clause::__anon1
mark	solver/SolverTypes.h	/^    uint32_t     mark        ()      const   { return header.mark; }$/;"	f	class:Minisat::Clause
mark	solver/SolverTypes.h	/^    void         mark        (uint32_t m)    { header.mark = m; }$/;"	f	class:Minisat::Clause
match	utils/ParseUtils.h	/^static bool match(B& in, const char* str) {$/;"	f	namespace:Minisat
max_bound	camlside/Caml.ml	/^    let max_bound = getMB 0.0 eIntv in$/;"	v
max_bound	camlside/file.h	/^double max_bound (char *filename){$/;"	f
max_bound	solver/Caml.ml	/^    let max_bound = getMB 0.0 eIntv in$/;"	v
max_bound	solver/file.h	/^double max_bound (char *filename){$/;"	f
max_learnts	solver/Solver.h	/^    double              max_learnts;$/;"	m	class:Minisat::Solver
max_literals	solver/Solver.h	/^    uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
meet	camlside/IA.ml	/^       method meet (other: inf_interval) =$/;"	m
meet	camlside/IA.ml	/^       method meet (other: interval) =$/;"	m	class:interval
memReadPeak	utils/System.cc	/^static inline int memReadPeak(void)$/;"	f	file:
memReadStat	utils/System.cc	/^static inline int memReadStat(int field)$/;"	f	file:
memUsed	utils/System.cc	/^double Minisat::memUsed() { return (double)memReadStat(0) * (double)getpagesize() \/ (1024*1024); }$/;"	f	class:Minisat
memUsedPeak	utils/System.cc	/^double Minisat::memUsedPeak() { $/;"	f	class:Minisat
memory	mtl/Alloc.h	/^    T*        memory;$/;"	m	class:Minisat::RegionAllocator
merge_list	camlside/Caml.ml	/^  let rec merge_list fpos lstUc = match lstUc with$/;"	v
merge_list	camlside/Caml_Smt.ml	/^let merge_list (l1, a) (l2, b) = (List.append l1 l2, a*.b)$/;"	v
merge_list	solver/Caml.ml	/^  let rec merge_list fpos lstUc = match lstUc with$/;"	v
merge_list	solver/Caml.ml	/^let merge_list (l1, a) (l2, b) = (List.append l1 l2, a*.b)$/;"	v
minus	camlside/Expr.ml	/^  let minus p1 p2 =$/;"	v	Module:Expr
mkLit	solver/SolverTypes.h	/^inline  Lit  mkLit     (Var var, bool sign) { Lit p; p.x = var + var + (int)sign; return p; }$/;"	f	namespace:Minisat
mkVarData	solver/Solver.h	/^    static inline VarData mkVarData(CRef cr, int l){ VarData d = {cr, l}; return d; }$/;"	f	class:Minisat::Solver
model	solver/Solver.h	/^    vec<lbool> model;             \/\/ If problem is satisfiable, this vector contains the model (if any).$/;"	m	class:Minisat::Solver
modelValue	solver/Solver.h	/^inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }$/;"	f	class:Minisat::Solver
modelValue	solver/Solver.h	/^inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }$/;"	f	class:Minisat::Solver
moveTo	mtl/Alloc.h	/^    void     moveTo(RegionAllocator& to) {$/;"	f	class:Minisat::RegionAllocator
moveTo	mtl/Map.h	/^    void moveTo(Map& other){$/;"	f	class:Minisat::Map
moveTo	mtl/Vec.h	/^    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }$/;"	f	class:Minisat::vec
moveTo	solver/SolverTypes.h	/^    void moveTo(CMap& other){ map.moveTo(other.map); }$/;"	f	class:Minisat::CMap
moveTo	solver/SolverTypes.h	/^    void moveTo(ClauseAllocator& to){$/;"	f	class:Minisat::ClauseAllocator
mul	camlside/IA.ml	/^      method mul (other: af1) = $/;"	m	class:af1
mul	camlside/IA.ml	/^      method mul (other: af2) = $/;"	m	class:af2
mul	camlside/IA.ml	/^      method mul (other: caf2) = $/;"	m	class:caf2
mul	camlside/IA.ml	/^      method mul (other: cai1) = $/;"	m	class:cai1
mul	camlside/IA.ml	/^      method mul (other: cai2) = $/;"	m
mul	camlside/IA.ml	/^      method mul (other: cai3) = $/;"	m	class:cai3
mul	camlside/IA.ml	/^      method mul (other: inf_interval)= $/;"	m
mul	camlside/IA.ml	/^      method mul (other: interval)= $/;"	m	class:interval
mul	camlside/IA.ml	/^  let mul (a:bound) (b:bound) =  $/;"	v
mul2	camlside/IA.ml	/^       method mul2 (c: float) = $/;"	m
mul2	camlside/IA.ml	/^       method mul2 (other: float) = $/;"	m	class:interval
mul2	camlside/IA.ml	/^     method mul2 (c: float)=$/;"	m
mul2	camlside/IA.ml	/^     method mul2 (c: float)=$/;"	m	class:af1
mul_cons	camlside/IA.ml	/^      method mul_cons(c: interval) = $/;"	m	class:cai2
mul_ei	camlside/IA.ml	/^      method mul_ei arr = $/;"	m	class:cai2
mul_eij	camlside/IA.ml	/^      method mul_eij ma = $/;"	m
mul_eijn	camlside/IA.ml	/^      method mul_eijn ma = $/;"	m
mul_ein	camlside/IA.ml	/^      method mul_ein arr = $/;"	m
mul_einjn	camlside/IA.ml	/^      method mul_einjn ma = $/;"	m
mul_k	camlside/IA.ml	/^      method mul_k (k1:interval) = $/;"	m
n	camlside/Caml.ml	/^        let n = ref neg in$/;"	v
n	solver/Caml.ml	/^        let n = ref neg in$/;"	v
nAssigns	solver/Solver.h	/^inline int      Solver::nAssigns      ()      const   { return trail.size(); }$/;"	f	class:Minisat::Solver
nClauses	solver/Solver.h	/^inline int      Solver::nClauses      ()      const   { return clauses.size(); }$/;"	f	class:Minisat::Solver
nFreeVars	solver/Solver.h	/^inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }$/;"	f	class:Minisat::Solver
nLearnts	solver/Solver.h	/^inline int      Solver::nLearnts      ()      const   { return learnts.size(); }$/;"	f	class:Minisat::Solver
nVars	solver/Solver.h	/^inline int      Solver::nVars         ()      const   { return vardata.size(); }$/;"	f	class:Minisat::Solver
name	utils/Options.h	/^    const char* name;$/;"	m	class:Minisat::Option
neg	camlside/Caml_Smt.ml	/^  let neg e = match e with$/;"	v
neg	solver/Caml.ml	/^  let neg e = match e with$/;"	v
newDecisionLevel	solver/Solver.h	/^inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }$/;"	f	class:Minisat::Solver
newVar	solver/Solver.cc	/^Var Solver::newVar(bool sign, bool dvar)$/;"	f	class:Solver
new_uk_cl	camlside/Caml.ml	/^	let new_uk_cl = sub_list uk_cl first_list in$/;"	v
new_uk_cl	solver/Caml.ml	/^	let new_uk_cl = sub_list uk_cl first_list in$/;"	v
nextCap	mtl/Vec.h	/^    static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }$/;"	f	class:Minisat::vec
nil_expr	camlside/Caml_Smt.ml	/^type nil_expr = $/;"	t	Module:Caml
nil_expr	solver/Caml.ml	/^type nil_expr = $/;"	t
nprimes	mtl/Map.h	/^static const int nprimes          = 25;$/;"	m	namespace:Minisat
num_of_lit	solver/file.h	/^int num_of_lit (string cl){$/;"	f
num_var	camlside/file.h	/^int num_var(char *filename){$/;"	f
num_var	solver/file.h	/^int num_var(char *filename){$/;"	f
occs	solver/SolverTypes.h	/^    vec<Vec>  occs;$/;"	m	class:Minisat::OccLists
ok	solver/Solver.h	/^    bool                ok;               \/\/ If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!$/;"	m	class:Minisat::Solver
okay	solver/Solver.h	/^inline bool     Solver::okay          ()      const   { return ok; }$/;"	f	class:Minisat::Solver
operator !=	solver/Solver.h	/^        bool operator!=(const Watcher& w) const { return cref != w.cref; }$/;"	f	struct:Minisat::Solver::Watcher
operator !=	solver/SolverTypes.h	/^    bool  operator != (lbool b) const { return !(*this == b); }$/;"	f	class:Minisat::lbool
operator !=	solver/SolverTypes.h	/^    bool operator != (Lit p) const { return x != p.x; }$/;"	f	struct:Minisat::Lit
operator &&	solver/SolverTypes.h	/^    lbool operator && (lbool b) const { $/;"	f	class:Minisat::lbool
operator ()	mtl/Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };$/;"	f	struct:Minisat::DeepEqual
operator ()	mtl/Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };$/;"	f	struct:Minisat::DeepHash
operator ()	mtl/Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };$/;"	f	struct:Minisat::Equal
operator ()	mtl/Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };$/;"	f	struct:Minisat::Hash
operator ()	mtl/Sort.h	/^    bool operator () (T x, T y) { return x < y; }$/;"	f	struct:Minisat::LessThan_default
operator ()	solver/Solver.cc	/^    bool operator () (CRef x, CRef y) { $/;"	f	struct:reduceDB_lt
operator ()	solver/Solver.h	/^        bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }$/;"	f	struct:Minisat::Solver::VarOrderLt
operator ()	solver/Solver.h	/^        bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }$/;"	f	struct:Minisat::Solver::WatcherDeleted
operator ()	solver/SolverTypes.h	/^        uint32_t operator()(CRef cr) const { return (uint32_t)cr; } };$/;"	f	struct:Minisat::CMap::CRefHash
operator ()	utils/Options.h	/^        bool operator()(const Option* x, const Option* y) {$/;"	f	struct:Minisat::Option::OptionLt
operator *	utils/ParseUtils.h	/^    int  operator *  () const { return (pos >= size) ? EOF : buf[pos]; }$/;"	f	class:Minisat::StreamBuffer
operator ++	utils/ParseUtils.h	/^    void operator ++ ()       { pos++; assureLookahead(); }$/;"	f	class:Minisat::StreamBuffer
operator <	solver/SolverTypes.h	/^    bool operator <  (Lit p) const { return x < p.x;  } \/\/ '<' makes p, ~p adjacent in the ordering.$/;"	f	struct:Minisat::Lit
operator =	mtl/Map.h	/^    Map<K,D,H,E>&  operator = (Map<K,D,H,E>& other) { assert(0); }$/;"	f	class:Minisat::Map
operator =	mtl/Vec.h	/^    vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }$/;"	f	class:Minisat::vec
operator =	utils/Options.h	/^    BoolOption& operator=(bool b)     { value = b; return *this; }$/;"	f	class:Minisat::BoolOption
operator =	utils/Options.h	/^    DoubleOption& operator=(double x)   { value = x; return *this; }$/;"	f	class:Minisat::DoubleOption
operator =	utils/Options.h	/^    Int64Option& operator= (int64_t x)  { value = x; return *this; }$/;"	f	class:Minisat::Int64Option
operator =	utils/Options.h	/^    IntOption& operator= (int32_t x)  { value = x; return *this; }$/;"	f	class:Minisat::IntOption
operator =	utils/Options.h	/^    StringOption& operator=    (const char* x)  { value = x; return *this; }$/;"	f	class:Minisat::StringOption
operator ==	solver/Solver.h	/^        bool operator==(const Watcher& w) const { return cref == w.cref; }$/;"	f	struct:Minisat::Solver::Watcher
operator ==	solver/SolverTypes.h	/^    bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }$/;"	f	class:Minisat::lbool
operator ==	solver/SolverTypes.h	/^    bool operator == (Lit p) const { return x == p.x; }$/;"	f	struct:Minisat::Lit
operator T*	mtl/Vec.h	/^    operator T*       (void)           { return data; }$/;"	f	class:Minisat::vec
operator []	mtl/Alloc.h	/^    T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }$/;"	f	class:Minisat::RegionAllocator
operator []	mtl/Alloc.h	/^    const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }$/;"	f	class:Minisat::RegionAllocator
operator []	mtl/Heap.h	/^    int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }$/;"	f	class:Minisat::Heap
operator []	mtl/Map.h	/^    D& operator [] (const K& k)$/;"	f	class:Minisat::Map
operator []	mtl/Map.h	/^    const D& operator [] (const K& k) const$/;"	f	class:Minisat::Map
operator []	mtl/Queue.h	/^    T&       operator [] (int index)        { assert(index >= 0); assert(index < size()); return buf[(first + index) % buf.size()]; }$/;"	f	class:Minisat::Queue
operator []	mtl/Queue.h	/^    const T& operator [] (int index) const  { assert(index >= 0); assert(index < size()); return buf[(first + index) % buf.size()]; }$/;"	f	class:Minisat::Queue
operator []	mtl/Vec.h	/^    T&       operator [] (int index)       { return data[index]; }$/;"	f	class:Minisat::vec
operator []	mtl/Vec.h	/^    const T& operator [] (int index) const { return data[index]; }$/;"	f	class:Minisat::vec
operator []	solver/SolverTypes.h	/^    Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }$/;"	f	class:Minisat::ClauseAllocator
operator []	solver/SolverTypes.h	/^    Lit          operator [] (int i) const   { return data[i].lit; }$/;"	f	class:Minisat::Clause
operator []	solver/SolverTypes.h	/^    Lit&         operator [] (int i)         { return data[i].lit; }$/;"	f	class:Minisat::Clause
operator []	solver/SolverTypes.h	/^    T&       operator [] (CRef cr)            { return map[cr]; }$/;"	f	class:Minisat::CMap
operator []	solver/SolverTypes.h	/^    Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }$/;"	f	class:Minisat::OccLists
operator []	solver/SolverTypes.h	/^    const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }$/;"	f	class:Minisat::ClauseAllocator
operator []	solver/SolverTypes.h	/^    const T& operator [] (CRef cr) const      { return map[cr]; }$/;"	f	class:Minisat::CMap
operator ^	solver/SolverTypes.h	/^    lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }$/;"	f	class:Minisat::lbool
operator ^	solver/SolverTypes.h	/^inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }$/;"	f	namespace:Minisat
operator bool	utils/Options.h	/^    operator    bool     (void) const { return value; }$/;"	f	class:Minisat::BoolOption
operator bool&	utils/Options.h	/^    operator    bool&    (void)       { return value; }$/;"	f	class:Minisat::BoolOption
operator const Lit*	solver/SolverTypes.h	/^    operator const Lit* (void) const         { return (Lit*)data; }$/;"	f	class:Minisat::Clause
operator const char*	utils/Options.h	/^    operator      const char*  (void) const     { return value; }$/;"	f	class:Minisat::StringOption
operator const char*&	utils/Options.h	/^    operator      const char*& (void)           { return value; }$/;"	f	class:Minisat::StringOption
operator double	utils/Options.h	/^    operator      double   (void) const { return value; }$/;"	f	class:Minisat::DoubleOption
operator double&	utils/Options.h	/^    operator      double&  (void)       { return value; }$/;"	f	class:Minisat::DoubleOption
operator int32_t	utils/Options.h	/^    operator   int32_t   (void) const { return value; }$/;"	f	class:Minisat::IntOption
operator int32_t&	utils/Options.h	/^    operator   int32_t&  (void)       { return value; }$/;"	f	class:Minisat::IntOption
operator int64_t	utils/Options.h	/^    operator     int64_t   (void) const { return value; }$/;"	f	class:Minisat::Int64Option
operator int64_t&	utils/Options.h	/^    operator     int64_t&  (void)       { return value; }$/;"	f	class:Minisat::Int64Option
operator ||	solver/SolverTypes.h	/^    lbool operator || (lbool b) const {$/;"	f	class:Minisat::lbool
operator ~	solver/SolverTypes.h	/^inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }$/;"	f	namespace:Minisat
order_heap	solver/Solver.h	/^    Heap<VarOrderLt>    order_heap;       \/\/ A priority queue of variables ordered with respect to the variable activity.$/;"	m	class:Minisat::Solver
p	camlside/Caml.ml	/^        let p = ref pos in$/;"	v
p	solver/Caml.ml	/^        let p = ref pos in$/;"	v
p'	camlside/Expr.ml	/^        let p' = Poly.remove v p in $/;"	v
p1	camlside/Caml.ml	/^      let (p1, n1) = get_pn sign e1 in$/;"	v
p1	solver/Caml.ml	/^      let (p1, n1) = get_pn sign e1 in$/;"	v
p2	camlside/Caml.ml	/^      let (p2, n2) = get_pn sign (Mul (Real (-1.0), e2)) in$/;"	v
p2	camlside/Caml.ml	/^      let (p2, n2) = get_pn sign e2 in$/;"	v
p2	solver/Caml.ml	/^      let (p2, n2) = get_pn sign (Mul (Real (-1.0), e2)) in$/;"	v
p2	solver/Caml.ml	/^      let (p2, n2) = get_pn sign e2 in$/;"	v
para	camlside/Caml.ml	/^    let para = int_of_float (max_bound \/. esl) in$/;"	v
para	solver/Caml.ml	/^    let para = int_of_float (max_bound \/. esl) in$/;"	v
parent	mtl/Heap.h	/^    static inline int parent(int i) { return (i-1) >> 1; }$/;"	f	class:Minisat::Heap
parse	utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::BoolOption
parse	utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::DoubleOption
parse	utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::Int64Option
parse	utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::IntOption
parse	utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::StringOption
parseInt	utils/ParseUtils.h	/^static int parseInt(B& in) {$/;"	f	namespace:Minisat
parseOptions	utils/Options.cc	/^void Minisat::parseOptions(int& argc, char** argv, bool strict)$/;"	f	class:Minisat
parse_DIMACS	solver/Dimacs.h	/^static void parse_DIMACS(gzFile input_stream, Solver& S) {$/;"	f	namespace:Minisat
parse_DIMACS_main	solver/Dimacs.h	/^static void parse_DIMACS_main(B& in, Solver& S) {$/;"	f	namespace:Minisat
peek	mtl/Map.h	/^    bool peek   (const K& k, D& d) const {$/;"	f	class:Minisat::Map
peek	mtl/Queue.h	/^    T    peek  () const { assert(first != end); return buf[first]; }$/;"	f	class:Minisat::Queue
percolateDown	mtl/Heap.h	/^    void percolateDown(int i)$/;"	f	class:Minisat::Heap
percolateUp	mtl/Heap.h	/^    void percolateUp(int i)$/;"	f	class:Minisat::Heap
phase_saving	solver/Solver.h	/^    int       phase_saving;       \/\/ Controls the level of phase saving (0=none, 1=limited, 2=full).$/;"	m	class:Minisat::Solver
pickBranchLit	solver/Solver.cc	/^Lit Solver::pickBranchLit()$/;"	f	class:Solver
plus	camlside/Expr.ml	/^  let plus p1 p2 =$/;"	v	Module:Expr
polarity	solver/Solver.h	/^    vec<char>           polarity;         \/\/ The preferred polarity of each variable.$/;"	m	class:Minisat::Solver
poly_eval	camlside/Caml.ml	/^  (*evaluate the bound of poly expression by type of interval arithmetic*)						     let poly_eval e ia assIntv = $/;"	v
poly_eval	solver/Caml.ml	/^  (*evaluate the bound of poly expression by type of interval arithmetic*)						     let poly_eval e ia assIntv = $/;"	v
poly_expr	camlside/ast.ml	/^type poly_expr = $/;"	t
poly_isCons	camlside/Caml_Smt.ml	/^let poly_isCons = function$/;"	v
poly_isCons	solver/Caml.ml	/^let poly_isCons = function$/;"	v
poly_toPrefix	camlside/Caml.ml	/^  let rec poly_toPrefix = function$/;"	v
poly_toPrefix	camlside/Caml_Smt.ml	/^let rec poly_toPrefix = function$/;"	v
poly_toPrefix	solver/Caml.ml	/^  let rec poly_toPrefix = function$/;"	v
poly_toString	camlside/Caml.ml	/^let rec poly_toString sign  = function$/;"	v	Module:Caml
poly_toString	camlside/Caml_Smt.ml	/^let rec poly_toString sign  = function$/;"	v
poly_toString	solver/Caml.ml	/^let rec poly_toString sign  = function$/;"	v	Module:Caml
pop	mtl/Queue.h	/^    void pop   () { assert(first != end); first++; if (first == buf.size()) first = 0; }$/;"	f	class:Minisat::Queue
pop	mtl/Vec.h	/^    void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }$/;"	f	class:Minisat::vec
pop	solver/SolverTypes.h	/^    void         pop         ()              { shrink(1); }$/;"	f	class:Minisat::Clause
pos	utils/ParseUtils.h	/^    int           pos;$/;"	m	class:Minisat::StreamBuffer
position	utils/ParseUtils.h	/^    int  position    () const { return pos; }$/;"	f	class:Minisat::StreamBuffer
positiveCheck	camlside/Caml.ml	/^      let positiveCheck = getPositive olstCheck iVar in$/;"	v
positiveCheck	solver/Caml.ml	/^      let positiveCheck = getPositive olstCheck iVar in$/;"	v
pow	camlside/IA.ml	/^       method pow (n: int) = $/;"	m
pow	camlside/IA.ml	/^       method pow (n: int) = $/;"	m	class:interval
pow	camlside/IA.ml	/^    let rec pow (t: af1) (n: int)= $/;"	v	Module:AF1
pow	camlside/IA.ml	/^    let rec pow (t: caf2) (n: int)= $/;"	v	Module:CAF2
pow	camlside/IA.ml	/^    let rec pow (t: cai1) (n: int)= $/;"	v	Module:CAI1
pow	camlside/IA.ml	/^    let rec pow (t: cai2) (n: int)= $/;"	v	Module:CAI2
pow	camlside/IA.ml	/^    let rec pow (t: cai3) (n: int)= $/;"	v	Module:CAI3
pow	camlside/IA.ml	/^   let rec pow (t: af2) (n: int)= $/;"	v	Module:AF2
primes	mtl/Map.h	/^static const int primes [nprimes] = { 31, 73, 151, 313, 643, 1291, 2593, 5233, 10501, 21013, 42073, 84181, 168451, 337219, 674701, 1349473, 2699299, 5398891, 10798093, 21596719, 43193641, 86387383, 172775299, 345550609, 691101253 };$/;"	m	namespace:Minisat
printForm	camlside/IA.ml	/^       method printForm =$/;"	m
printForm	camlside/IA.ml	/^       method printForm =$/;"	m	class:interval
printForm	camlside/IA.ml	/^      method printForm = $/;"	m
printForm	camlside/IA.ml	/^      method printForm = $/;"	m	class:af1
printForm	camlside/IA.ml	/^      method printForm = $/;"	m	class:caf2
printForm	camlside/IA.ml	/^      method printForm = $/;"	m	class:cai1
printForm	camlside/IA.ml	/^      method printForm = $/;"	m	class:cai2
printForm	camlside/IA.ml	/^      method printForm = $/;"	m	class:cai3
printStats	solver/Main.cc	/^void printStats(Solver& solver)$/;"	f
printUsageAndExit	utils/Options.cc	/^void Minisat::printUsageAndExit (int argc, char** argv, bool verbose)$/;"	f	class:Minisat
progressEstimate	solver/Solver.cc	/^double Solver::progressEstimate() const$/;"	f	class:Solver
progress_estimate	solver/Solver.h	/^    double              progress_estimate;\/\/ Set by 'search()'.$/;"	m	class:Minisat::Solver
propagate	solver/Solver.cc	/^CRef Solver::propagate()$/;"	f	class:Solver
propagation_budget	solver/Solver.h	/^    int64_t             propagation_budget; \/\/ -1 means no budget.$/;"	m	class:Minisat::Solver
propagations	solver/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
push	mtl/Vec.h	/^    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }$/;"	f	class:Minisat::vec
push	mtl/Vec.h	/^    void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }$/;"	f	class:Minisat::vec
push_	mtl/Vec.h	/^    void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }$/;"	f	class:Minisat::vec
qhead	solver/Solver.h	/^    int                 qhead;            \/\/ Head of queue (as index into the trail -- no more explicit propagation queue in MiniSat).$/;"	m	class:Minisat::Solver
random_seed	solver/Solver.h	/^    double    random_seed;$/;"	m	class:Minisat::Solver
random_var_freq	solver/Solver.h	/^    double    random_var_freq;$/;"	m	class:Minisat::Solver
range	utils/Options.h	/^    DoubleRange range;$/;"	m	class:Minisat::DoubleOption
range	utils/Options.h	/^    Int64Range range;$/;"	m	class:Minisat::Int64Option
range	utils/Options.h	/^    IntRange range;$/;"	m	class:Minisat::IntOption
read	camlside/Caml.ml	/^  let read s = Parser.main Lexer.lex (Lexing.from_string s)$/;"	v	Module:Caml
read	camlside/Caml_Smt.ml	/^let read s = SmtParser.main SmtLexer.lex (Lexing.from_string s)$/;"	v	Module:Caml
read	solver/Caml.ml	/^  let read s = Parser.main Lexer.lex (Lexing.from_string s)$/;"	v	Module:Caml
readClause	solver/Dimacs.h	/^static void readClause(B& in, Solver& S, vec<Lit>& lits) {$/;"	f	namespace:Minisat
readFile	camlside/file.h	/^string readFile (char *filename){$/;"	f
readFile	solver/file.h	/^string readFile (char *filename){$/;"	f
reason	solver/Solver.h	/^    struct VarData { CRef reason; int level; };$/;"	m	struct:Minisat::Solver::VarData
reason	solver/Solver.h	/^inline CRef Solver::reason(Var x) const { return vardata[x].reason; }$/;"	f	class:Minisat::Solver
rebuildOrderHeap	solver/Solver.cc	/^void Solver::rebuildOrderHeap()$/;"	f	class:Solver
redLstCheck	camlside/Caml.ml	/^  let rec redLstCheck l1 l2 lstIDLit= match l2 with$/;"	v
redLstCheck	solver/Caml.ml	/^  let rec redLstCheck l1 l2 lstIDLit= match l2 with$/;"	v
red_ass	camlside/Caml.ml	/^  let rec red_ass assIntv lstVar = match assIntv with$/;"	v
red_ass	solver/Caml.ml	/^  let rec red_ass assIntv lstVar = match assIntv with$/;"	v
red_cons	camlside/Caml_Smt.ml	/^  let rec red_cons lst = match lst with$/;"	v
red_cons	solver/Caml.ml	/^  let rec red_cons lst = match lst with$/;"	v
red_list	camlside/Caml.ml	/^  let red_list l = set_list [] l$/;"	v	Module:Caml
red_list	camlside/Caml_Smt.ml	/^  let red_list l = $/;"	v
red_list	camlside/Caml_Smt.ml	/^  let red_list l = set_list [] l$/;"	v
red_list	solver/Caml.ml	/^  let red_list l = set_list [] l$/;"	v	Module:Caml
reduce	camlside/Expr.ml	/^  let reduce (e: Exp.smt_poly_expr) = reify (eval e)$/;"	v
reduceDB	solver/Solver.cc	/^void Solver::reduceDB()$/;"	f	class:Solver
reduceDB_lt	solver/Solver.cc	/^    reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}$/;"	f	struct:reduceDB_lt
reduceDB_lt	solver/Solver.cc	/^struct reduceDB_lt { $/;"	s	file:
reduce_expr	camlside/Caml_Smt.ml	/^  let rec reduce_expr e = match e with $/;"	v
reduce_expr	solver/Caml.ml	/^  let rec reduce_expr e = match e with $/;"	v
refor_expr	camlside/Caml_Smt.ml	/^let rec refor_expr e (c: float) = match e with$/;"	v
refor_expr	solver/Caml.ml	/^let rec refor_expr e (c: float) = match e with$/;"	v
rehash	mtl/Map.h	/^    void    rehash () {$/;"	f	class:Minisat::Map
rel	camlside/Caml.ml	/^  let rec rel e lstAss lstVar = match lstAss with$/;"	v
rel	solver/Caml.ml	/^  let rec rel e lstAss lstVar = match lstAss with$/;"	v
rel	solver/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon2
rel_all	camlside/Caml.ml	/^  let rec rel_all l1 l2 lstVar = match l1 with$/;"	v
rel_all	solver/Caml.ml	/^  let rec rel_all l1 l2 lstVar = match l1 with$/;"	v
reloc	solver/SolverTypes.h	/^    void reloc(CRef& cr, ClauseAllocator& to)$/;"	f	class:Minisat::ClauseAllocator
relocAll	solver/Solver.cc	/^void Solver::relocAll(ClauseAllocator& to)$/;"	f	class:Solver
relocate	solver/SolverTypes.h	/^    void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }$/;"	f	class:Minisat::Clause
relocation	solver/SolverTypes.h	/^    CRef         relocation  ()      const   { return data[0].rel; }$/;"	f	class:Minisat::Clause
reloced	solver/SolverTypes.h	/^        unsigned reloced   : 1;$/;"	m	struct:Minisat::Clause::__anon1
reloced	solver/SolverTypes.h	/^    bool         reloced     ()      const   { return header.reloced; }$/;"	f	class:Minisat::Clause
remLstCheck	camlside/Caml.ml	/^  let rec remLstCheck l e lstIDLit= match l with$/;"	v
remLstCheck	solver/Caml.ml	/^  let rec remLstCheck l e lstIDLit= match l with$/;"	v
rem_list	camlside/Caml_Smt.ml	/^let rec rem_list l a = match l with$/;"	v
rem_list	solver/Caml.ml	/^let rec rem_list l a = match l with$/;"	v
rem_var	camlside/Caml_Smt.ml	/^let rem_var e = match e with $/;"	v
rem_var	solver/Caml.ml	/^let rem_var e = match e with $/;"	v
rem_var1	camlside/Caml_Smt.ml	/^let rem_var1 e =$/;"	v
rem_var1	solver/Caml.ml	/^let rem_var1 e =$/;"	v
remain_cons	camlside/Caml.ml	/^  let remain_cons gr uk = $/;"	v
remain_cons	solver/Caml.ml	/^  let remain_cons gr uk = $/;"	v
remov_nil	camlside/Caml_Smt.ml	/^let rec remov_nil expr = match expr with$/;"	v
remov_nil	solver/Caml.ml	/^let rec remov_nil expr = match expr with$/;"	v
remove	mtl/Alg.h	/^static inline void remove(V& ts, const T& t)$/;"	f	namespace:Minisat
remove	mtl/Map.h	/^    void remove(const K& k) {$/;"	f	class:Minisat::Map
remove	solver/SolverTypes.h	/^    void     remove      (CRef cr)            { map.remove(cr); }$/;"	f	class:Minisat::CMap
removeClause	solver/Solver.cc	/^void Solver::removeClause(CRef cr) {$/;"	f	class:Solver
removeMin	mtl/Heap.h	/^    int  removeMin()$/;"	f	class:Minisat::Heap
removeSatisfied	solver/Solver.cc	/^void Solver::removeSatisfied(vec<CRef>& cs)$/;"	f	class:Solver
remove_div	camlside/Caml_Smt.ml	/^  let rec remove_div e = match e with$/;"	v
remove_div	solver/Caml.ml	/^  let rec remove_div e = match e with$/;"	v
remove_empty	camlside/Caml.ml	/^  let rec remove_empty r l = match l with$/;"	v
remove_empty	solver/Caml.ml	/^  let rec remove_empty r l = match l with$/;"	v
remove_not	camlside/Caml_Smt.ml	/^ let rec remove_not e = match e with $/;"	v
remove_satisfied	solver/Solver.h	/^    bool                remove_satisfied; \/\/ Indicates whether possibly inefficient linear scan for satisfied clauses should be performed in 'simplify'.$/;"	m	class:Minisat::Solver
remove_space	camlside/file.h	/^string remove_space (string s){$/;"	f
remove_space	solver/file.h	/^string remove_space (string s){$/;"	f
remove_trivial	camlside/Caml_Smt.ml	/^  let rec remove_trivial = function$/;"	v
remove_trivial	solver/Caml.ml	/^  let rec remove_trivial = function$/;"	v
remove_zero	camlside/Caml_Smt.ml	/^let rec remove_zero e = match e with$/;"	v
remove_zero	solver/Caml.ml	/^let rec remove_zero e = match e with$/;"	v
res	camlside/Caml.ml	/^	    let res = checkSat e ia assIntv in$/;"	v
res	camlside/Caml.ml	/^      let (res, us, uk_cl) = eval_all 1 "" [] eAss ia assIntv checkVarID in$/;"	v
res	solver/Caml.ml	/^	    let res = checkSat e ia assIntv in$/;"	v
res	solver/Caml.ml	/^      let (res, us, uk_cl) = eval_all 1 "" [] eAss ia assIntv checkVarID in$/;"	v
restart_first	solver/Solver.h	/^    int       restart_first;      \/\/ The initial restart limit.                                                                (default 100)$/;"	m	class:Minisat::Solver
restart_inc	solver/Solver.h	/^    double    restart_inc;        \/\/ The factor with which the restart limit is multiplied in each restart.                    (default 1.5)$/;"	m	class:Minisat::Solver
result	camlside/IA.ml	/^	let result = new inf_interval val_lo val_hi in$/;"	v
rev	camlside/Caml.ml	/^let rev = function$/;"	v	Module:Caml
rev	camlside/Caml_Smt.ml	/^let rev = function$/;"	v	Module:Caml
rev	solver/Caml.ml	/^let rev = function$/;"	v
rev	solver/Caml.ml	/^let rev = function$/;"	v	Module:Caml
right	mtl/Heap.h	/^    static inline int right (int i) { return (i+1)*2; }$/;"	f	class:Minisat::Heap
rightExp	camlside/Caml.ml	/^  let rightExp = function$/;"	v	Module:Caml
rightExp	solver/Caml.ml	/^  let rightExp = function$/;"	v	Module:Caml
rnd_decisions	solver/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
rnd_init_act	solver/Solver.h	/^    bool      rnd_init_act;       \/\/ Initialize variable activities with a small random value.$/;"	m	class:Minisat::Solver
rnd_pol	solver/Solver.h	/^    bool      rnd_pol;            \/\/ Use random polarities for branching heuristics.$/;"	m	class:Minisat::Solver
round_off	camlside/Caml.ml	/^let round_off (r: float) (n:int) = $/;"	v	Module:Caml
round_off	solver/Caml.ml	/^let round_off (r: float) (n:int) = $/;"	v	Module:Caml
round_test	camlside/Caml.ml	/^let rec round_test = function$/;"	v	Module:Caml
round_test	solver/Caml.ml	/^let rec round_test = function$/;"	v	Module:Caml
s	camlside/Caml.ml	/^	let (s, pos1, neg1) = get_pos_neg (pos, neg) sign e1 in$/;"	v
s	camlside/Caml.ml	/^      let s = get_sign sign e in$/;"	v
s	solver/Caml.ml	/^	let (s, pos1, neg1) = get_pos_neg (pos, neg) sign e1 in$/;"	v
s	solver/Caml.ml	/^      let s = get_sign sign e in$/;"	v
s1	camlside/Caml.ml	/^	let (s1, pos1, neg1) = get_pos_neg ([], []) sign e1 in$/;"	v
s1	camlside/Caml.ml	/^      let s1 = get_sign sign e1 in$/;"	v
s1	solver/Caml.ml	/^	let (s1, pos1, neg1) = get_pos_neg ([], []) sign e1 in$/;"	v
s1	solver/Caml.ml	/^      let s1 = get_sign sign e1 in$/;"	v
s2	camlside/Caml.ml	/^	let (s2, pos2, neg2) = get_pos_neg ([], []) 1.0 e2 in$/;"	v
s2	camlside/Caml.ml	/^      let s2 = get_sign 1.0 e2 in$/;"	v
s2	solver/Caml.ml	/^	let (s2, pos2, neg2) = get_pos_neg ([], []) 1.0 e2 in$/;"	v
s2	solver/Caml.ml	/^      let s2 = get_sign 1.0 e2 in$/;"	v
sInterval	camlside/Caml.ml	/^	   let (sInterval, sLearn, bump_vars, isDecomp) = dynamicDecom_pos assIntv dIntv checkVarID iVar clTest_US esl in$/;"	v
sInterval	solver/Caml.ml	/^	   let (sInterval, sLearn, bump_vars, isDecomp) = dynamicDecom_pos assIntv dIntv checkVarID iVar clTest_US esl in$/;"	v
sLog	camlside/Caml.ml	/^	   let sLog = logTest assIntv a eAss uk_cl ia in$/;"	v
sLog	solver/Caml.ml	/^	   let sLog = logTest assIntv a eAss uk_cl ia in$/;"	v
sTrivialClause	camlside/Caml.ml	/^    let sTrivialClause = "-" ^string_of_int totalVars ^ " " ^string_of_int totalVars^ " 0" in$/;"	v
sTrivialClause	solver/Caml.ml	/^    let sTrivialClause = "-" ^string_of_int totalVars ^ " " ^string_of_int totalVars^ " 0" in$/;"	v
sat	camlside/Caml.ml	/^  let (sat,s) = isConsistent eAss in$/;"	v
sat	solver/Caml.ml	/^  let (sat,s) = isConsistent eAss in$/;"	v
sat_find	camlside/Caml.ml	/^  let rec sat_find r e vass ass = match ass with$/;"	v
sat_find	solver/Caml.ml	/^  let rec sat_find r e vass ass = match ass with$/;"	v
sat_find1	camlside/Caml.ml	/^  let rec sat_find1 (e1, d1) r e vass ass = match ass with$/;"	v
sat_find1	solver/Caml.ml	/^  let rec sat_find1 (e1, d1) r e vass ass = match ass with$/;"	v
sat_group	camlside/Caml.ml	/^  let sat_group aAss rmAss rs =$/;"	v
sat_group	solver/Caml.ml	/^  let sat_group aAss rmAss rs =$/;"	v
satisfied	solver/Solver.cc	/^bool Solver::satisfied(const Clause& c) const {$/;"	f	class:Solver
search	solver/Solver.cc	/^lbool Solver::search(int nof_conflicts)$/;"	f	class:Solver
search_inside	camlside/Caml.ml	/^  let rec search_inside lvars oAss uAss uk_cl = match uk_cl with$/;"	v
search_inside	solver/Caml.ml	/^  let rec search_inside lvars oAss uAss uk_cl = match uk_cl with$/;"	v
search_sat	camlside/Caml.ml	/^  let rec search_sat e ass = match ass with$/;"	v
search_sat	solver/Caml.ml	/^  let rec search_sat e ass = match ass with$/;"	v
search_tc2	camlside/Caml.ml	/^  let search_tc2 uk_cl assIntv strTestUS esl =      $/;"	v
search_tc2	solver/Caml.ml	/^  let search_tc2 uk_cl assIntv strTestUS esl =      $/;"	v
seen	solver/Solver.h	/^    vec<char>           seen;$/;"	m	class:Minisat::Solver
selectionSort	mtl/Sort.h	/^template <class T> static inline void selectionSort(T* array, int size) {$/;"	f	namespace:Minisat
selectionSort	mtl/Sort.h	/^void selectionSort(T* array, int size, LessThan lt)$/;"	f	namespace:Minisat
setConfBudget	solver/Solver.h	/^inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }$/;"	f	class:Minisat::Solver
setDecisionVar	solver/Solver.h	/^inline void     Solver::setDecisionVar(Var v, bool b) $/;"	f	class:Minisat::Solver
setHelpPrefixStr	utils/Options.cc	/^void Minisat::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }$/;"	f	class:Minisat
setPolarity	solver/Solver.h	/^inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }$/;"	f	class:Minisat::Solver
setPropBudget	solver/Solver.h	/^inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }$/;"	f	class:Minisat::Solver
setUsageHelp	utils/Options.cc	/^void Minisat::setUsageHelp      (const char* str){ Option::getUsageString() = str; }$/;"	f	class:Minisat
set_a	camlside/IA.ml	/^      method set_a a1 = a<-a1$/;"	m	class:af1
set_a	camlside/IA.ml	/^      method set_a a1 = a<-a1$/;"	m	class:af2
set_a	camlside/IA.ml	/^      method set_a a1 = a<-a1$/;"	m	class:caf2
set_a	camlside/IA.ml	/^      method set_a a1 = a<-a1$/;"	m	class:cai1
set_a	camlside/IA.ml	/^      method set_a a1 = a<-a1$/;"	m	class:cai2
set_a	camlside/IA.ml	/^      method set_a a1 = a<-a1$/;"	m	class:cai3
set_ar	camlside/IA.ml	/^      method set_ar ar1 = ar<-ar1$/;"	m	class:af1
set_ar	camlside/IA.ml	/^      method set_ar ar1 = ar<-ar1$/;"	m	class:af2
set_ar	camlside/IA.ml	/^      method set_ar ar1 = ar<-ar1$/;"	m	class:caf2
set_ar	camlside/IA.ml	/^      method set_ar ar1 = ar<-ar1$/;"	m	class:cai1
set_ar	camlside/IA.ml	/^      method set_ar ar1 = ar<-ar1$/;"	m	class:cai2
set_ar	camlside/IA.ml	/^      method set_ar ar1 = ar<-ar1$/;"	m	class:cai3
set_h	camlside/IA.ml	/^      method set_h h1 = h<-h1$/;"	m	class:interval
set_k	camlside/IA.ml	/^      method set_k k1 = k<- abs_float (k1) $/;"	m	class:af1
set_k	camlside/IA.ml	/^      method set_k k1 = k<- abs_float (k1) $/;"	m	class:af2
set_k	camlside/IA.ml	/^      method set_k k1 = k<- k1 $/;"	m	class:caf2
set_k	camlside/IA.ml	/^      method set_k k1 = k<- k1 $/;"	m	class:cai1
set_k	camlside/IA.ml	/^      method set_k k1 = k<- k1 $/;"	m	class:cai2
set_k	camlside/IA.ml	/^      method set_k k1 = k<- k1 $/;"	m	class:cai3
set_kn	camlside/IA.ml	/^      method set_kn kn1 = kn<- abs_float (kn1) $/;"	m	class:af2
set_kp	camlside/IA.ml	/^      method set_kp kp1 = kp<- abs_float (kp1) $/;"	m	class:af2
set_l	camlside/IA.ml	/^      method set_l l1 = l<-l1$/;"	m	class:interval
set_list	camlside/Caml.ml	/^  let rec set_list l1 l2 = match l2 with$/;"	v	Module:Caml
set_list	camlside/Caml_Smt.ml	/^  let rec set_list l1 l2 = match l2 with$/;"	v
set_list	solver/Caml.ml	/^  let rec set_list l1 l2 = match l2 with$/;"	v	Module:Caml
set_m	camlside/IA.ml	/^      method set_m m1 = m<-m1$/;"	m	class:cai3
set_m1	camlside/IA.ml	/^      method set_m1 ma1 = m1<-ma1$/;"	m	class:cai2
set_m2	camlside/IA.ml	/^      method set_m2 ma2 = m2<-ma2$/;"	m	class:cai2
set_m3	camlside/IA.ml	/^      method set_m3 ma3 = m3<-ma3$/;"	m	class:cai2
show	camlside/Expr.ml	/^  let show p = Poly.fold (fun vars coeff acc -> (vars, coeff)::acc) p [] $/;"	v	Module:Expr
shrink	mtl/Vec.h	/^    void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }$/;"	f	class:Minisat::vec
shrink	solver/SolverTypes.h	/^    void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }$/;"	f	class:Minisat::Clause
shrink_	mtl/Vec.h	/^    void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }$/;"	f	class:Minisat::vec
sign	solver/SolverTypes.h	/^inline  bool sign      (Lit p)              { return p.x & 1; }$/;"	f	namespace:Minisat
sign_simp	camlside/Caml.ml	/^let sign_simp sign (num: float) = match sign with$/;"	v	Module:Caml
sign_simp	camlside/Caml_Smt.ml	/^let sign_simp sign (num: float) = match sign with$/;"	v
sign_simp	solver/Caml.ml	/^let sign_simp sign (num: float) = match sign with$/;"	v
sign_simp	solver/Caml.ml	/^let sign_simp sign (num: float) = match sign with$/;"	v	Module:Caml
simpDB_assigns	solver/Solver.h	/^    int                 simpDB_assigns;   \/\/ Number of top-level assignments since last execution of 'simplify()'.$/;"	m	class:Minisat::Solver
simpDB_props	solver/Solver.h	/^    int64_t             simpDB_props;     \/\/ Remaining number of propagations that must be made before next execution of 'simplify()'.$/;"	m	class:Minisat::Solver
simp_cons	camlside/Caml_Smt.ml	/^let rec simp_cons  exp = match exp with$/;"	v
simp_cons	solver/Caml.ml	/^let rec simp_cons  exp = match exp with$/;"	v
simp_expr	camlside/Caml_Smt.ml	/^let simp_expr e1 e2 = $/;"	v
simp_expr	solver/Caml.ml	/^let simp_expr e1 e2 = $/;"	v
simplify	solver/Solver.cc	/^bool Solver::simplify()$/;"	f	class:Solver
simplify_bool	camlside/Caml_Smt.ml	/^let rec simplify_bool e = match e with$/;"	v
simplify_bool	solver/Caml.ml	/^let rec simplify_bool e = match e with$/;"	v
simplify_expr	camlside/Caml_Smt.ml	/^let rec simplify_expr e = match e with$/;"	v
simplify_expr	solver/Caml.ml	/^let rec simplify_expr e = match e with$/;"	v
size	mtl/Alloc.h	/^    uint32_t size      () const      { return sz; }$/;"	f	class:Minisat::RegionAllocator
size	mtl/Heap.h	/^    int  size      ()          const { return heap.size(); }$/;"	f	class:Minisat::Heap
size	mtl/Map.h	/^    int        size;$/;"	m	class:Minisat::Map
size	mtl/Queue.h	/^    int  size  () const { return (end >= first) ? end - first : end - first + buf.size(); }$/;"	f	class:Minisat::Queue
size	mtl/Vec.h	/^    int      size     (void) const     { return sz; }$/;"	f	class:Minisat::vec
size	solver/SolverTypes.h	/^        unsigned size      : 27; }                            header;$/;"	m	struct:Minisat::Clause::__anon1
size	solver/SolverTypes.h	/^    int          size        ()      const   { return header.size; }$/;"	f	class:Minisat::Clause
size	solver/SolverTypes.h	/^    int      size        ()                const      { return map.elems(); }$/;"	f	class:Minisat::CMap
size	utils/ParseUtils.h	/^    int           size;$/;"	m	class:Minisat::StreamBuffer
skipLine	utils/ParseUtils.h	/^static void skipLine(B& in) {$/;"	f	namespace:Minisat
skipWhitespace	utils/ParseUtils.h	/^static void skipWhitespace(B& in) {$/;"	f	namespace:Minisat
smt_ass	solver/file.h	/^string smt_ass (char *filename){$/;"	f
smt_bool_expr	camlside/Exp.ml	/^type smt_bool_expr = $/;"	t
smt_bool_toString	solver/Caml.ml	/^let rec smt_bool_toString = function$/;"	v
smt_get_vars	solver/Caml.ml	/^  let rec smt_get_vars = function$/;"	v
smt_getintv	solver/file.h	/^string smt_getintv (char *filename){$/;"	f
smt_intv	camlside/file.h	/^string smt_intv (char *filename){$/;"	f
smt_intv	solver/file.h	/^string smt_intv (char *filename){$/;"	f
smt_poly_expr	camlside/Exp.ml	/^type smt_poly_expr = $/;"	t
smt_poly_toPrefix	solver/Caml.ml	/^let rec smt_poly_toPrefix = function$/;"	v
smt_poly_toString	solver/Caml.ml	/^let rec smt_poly_toString sign  = function$/;"	v
smt_read	solver/Caml.ml	/^let smt_read s = SmtParser.main SmtLexer.lex (Lexing.from_string s)$/;"	v
smudge	solver/SolverTypes.h	/^    void  smudge    (const Idx& idx){$/;"	f	class:Minisat::OccLists
solve	solver/Solver.h	/^inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == l_True; }$/;"	f	class:Minisat::Solver
solve	solver/Solver.h	/^inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == l_True; }$/;"	f	class:Minisat::Solver
solve	solver/Solver.h	/^inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == l_True; }$/;"	f	class:Minisat::Solver
solve	solver/Solver.h	/^inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == l_True; }$/;"	f	class:Minisat::Solver
solve	solver/Solver.h	/^inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == l_True; }$/;"	f	class:Minisat::Solver
solveLimited	solver/Solver.h	/^inline lbool    Solver::solveLimited  (const vec<Lit>& assumps){ assumps.copyTo(assumptions); return solve_(); }$/;"	f	class:Minisat::Solver
solve_	solver/Solver.cc	/^lbool Solver::solve_()$/;"	f	class:Solver
solver	solver/Main.cc	/^static Solver* solver;$/;"	v	file:
solver_addClause	solver/Main.cc	/^void solver_addClause (Solver& solv, string reason){$/;"	f
solver_bumping	solver/Main.cc	/^void solver_bumping (Solver& solv, string bump_vars){$/;"	f
solves	solver/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
sort	camlside/Expr.ml	/^  let sort vars = List.sort String.compare vars $/;"	v	Module:Expr
sort	mtl/Sort.h	/^template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {$/;"	f	namespace:Minisat
sort	mtl/Sort.h	/^template <class T> static inline void sort(T* array, int size) {$/;"	f	namespace:Minisat
sort	mtl/Sort.h	/^template <class T> void sort(vec<T>& v) {$/;"	f	namespace:Minisat
sort	mtl/Sort.h	/^void sort(T* array, int size, LessThan lt)$/;"	f	namespace:Minisat
starts	solver/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
str	camlside/Caml.ml	/^	      let str = var_exp e checkVarID in $/;"	v
str	solver/Caml.ml	/^	      let str = var_exp e checkVarID in $/;"	v
strengthen	solver/SolverTypes.h	/^inline void Clause::strengthen(Lit p)$/;"	f	class:Minisat::Clause
sub	camlside/Caml.ml	/^      let sub = sub_constraints first_cons uk_cl in$/;"	v
sub	camlside/IA.ml	/^      method sub (other: af1) = $/;"	m	class:af1
sub	camlside/IA.ml	/^      method sub (other: af2) = $/;"	m	class:af2
sub	camlside/IA.ml	/^      method sub (other: caf2) = $/;"	m	class:caf2
sub	camlside/IA.ml	/^      method sub (other: cai1) = $/;"	m	class:cai1
sub	camlside/IA.ml	/^      method sub (other: cai2) = 	$/;"	m	class:cai2
sub	camlside/IA.ml	/^      method sub (other: cai3) = $/;"	m	class:cai3
sub	camlside/IA.ml	/^      method sub (other: inf_interval)= $/;"	m
sub	camlside/IA.ml	/^      method sub (other: interval)= $/;"	m	class:interval
sub	solver/Caml.ml	/^      let sub = sub_constraints first_cons uk_cl in$/;"	v
sub2	camlside/IA.ml	/^      method sub2 (c: float) = $/;"	m	class:af1
sub2	camlside/IA.ml	/^      method sub2 (c: float) = $/;"	m	class:af2
sub2	camlside/IA.ml	/^      method sub2 (c: float) = $/;"	m	class:caf2
sub2	camlside/IA.ml	/^      method sub2 (c: float) = $/;"	m	class:cai1
sub2	camlside/IA.ml	/^      method sub2 (c: float) = $/;"	m	class:cai2
sub2	camlside/IA.ml	/^      method sub2 (c: float) = $/;"	m	class:cai3
sub2	camlside/IA.ml	/^      method sub2 (c: float)= $/;"	m
sub2	camlside/IA.ml	/^      method sub2 (c: float)= $/;"	m	class:interval
sub_ass	camlside/Caml.ml	/^  let sub_ass = function$/;"	v	Module:Caml
sub_ass	solver/Caml.ml	/^  let sub_ass = function$/;"	v	Module:Caml
sub_constraints	camlside/Caml.ml	/^  let rec sub_constraints e l = match l with$/;"	v
sub_constraints	solver/Caml.ml	/^  let rec sub_constraints e l = match l with$/;"	v
sub_intv	camlside/Caml.ml	/^  let sub_intv = function$/;"	v	Module:Caml
sub_intv	solver/Caml.ml	/^  let sub_intv = function$/;"	v	Module:Caml
sub_list	camlside/Caml.ml	/^  let rec sub_list l1 l2 = $/;"	v
sub_list	solver/Caml.ml	/^  let rec sub_list l1 l2 = $/;"	v
subset_eq	camlside/Caml.ml	/^  let subset_eq l1 l2 =$/;"	v
subset_eq	solver/Caml.ml	/^  let subset_eq l1 l2 =$/;"	v
subset_list	camlside/Caml.ml	/^  let rec subset_list l1 l2 = match l1 with$/;"	v
subset_list	solver/Caml.ml	/^  let rec subset_list l1 l2 = match l1 with$/;"	v
subst_bool	camlside/Caml_Smt.ml	/^let rec subst_bool bass pass = function$/;"	v	Module:Caml
subst_bool	solver/Caml.ml	/^let rec subst_bool bass pass = function$/;"	v
subst_poly	camlside/Caml_Smt.ml	/^let rec subst_poly ass = function$/;"	v	Module:Caml
subst_poly	solver/Caml.ml	/^let rec subst_poly ass = function$/;"	v
subsumes	solver/SolverTypes.h	/^inline Lit Clause::subsumes(const Clause& other) const$/;"	f	class:Minisat::Clause
sum_total_var	camlside/Caml.ml	/^  let rec sum_total_var init mb = $/;"	v	Module:Caml
sum_total_var	solver/Caml.ml	/^  let rec sum_total_var init mb = $/;"	v	Module:Caml
sz	mtl/Alloc.h	/^    uint32_t  sz;$/;"	m	class:Minisat::RegionAllocator
sz	mtl/Vec.h	/^    int sz;$/;"	m	class:Minisat::vec
t	camlside/Expr.ml	/^    type t = var list $/;"	t	Module:MultiVar
table	mtl/Map.h	/^    vec<Pair>* table;$/;"	m	class:Minisat::Map
tc	camlside/Caml.ml	/^	 let (tc, sTest, clTest_US, a) =  search_tc2 uk_cl assIntv strTestUS esl in$/;"	v
tc	camlside/Caml.ml	/^      let (tc, fvars, first_tc, uAss, reason) = first_search [] [] lstTc first_list in$/;"	v
tc	solver/Caml.ml	/^	 let (tc, sTest, clTest_US, a) =  search_tc2 uk_cl assIntv strTestUS esl in$/;"	v
tc	solver/Caml.ml	/^      let (tc, fvars, first_tc, uAss, reason) = first_search [] [] lstTc first_list in$/;"	v
tc1	camlside/Caml.ml	/^	let (tc1, lv, satTC, reason) = search_inside fvars first_tc uAss new_uk_cl in$/;"	v
tc1	solver/Caml.ml	/^	let (tc1, lv, satTC, reason) = search_inside fvars first_tc uAss new_uk_cl in$/;"	v
times	camlside/Expr.ml	/^  let times p1 p2 = (* naive implementation *) $/;"	v	Module:Expr
tmp	camlside/Caml.ml	/^      let tmp = (ftemp checkVarID) ^ ". lstCheck = " ^ (toString_list lstCheck) in$/;"	v
tmp	solver/Caml.ml	/^      let tmp = (ftemp checkVarID) ^ ". lstCheck = " ^ (toString_list lstCheck) in$/;"	v
toAf1	camlside/Util.ml	/^   let toAf1 (it: IA.interval) (id:int) (size: int) = $/;"	v	Module:Util
toAf2	camlside/Util.ml	/^   let toAf2 (it: IA.interval) (id:int) (size: int) = $/;"	v
toCaf2	camlside/Util.ml	/^   let toCaf2 (it: IA.interval) (id:int) (size: int) = $/;"	v
toCai1	camlside/Util.ml	/^   let toCai1 (it: IA.interval) (id:int) (size: int) = $/;"	v
toCai2	camlside/Util.ml	/^   let toCai2 (it: IA.interval) (id:int) (size: int) = $/;"	v
toCai3	camlside/Util.ml	/^   let toCai3 (it: IA.interval) (id:int) (size: int) = $/;"	v
toDimacs	solver/Solver.cc	/^void Solver::toDimacs(FILE* f, Clause& c, vec<Var>& map, Var& max)$/;"	f	class:Solver
toDimacs	solver/Solver.cc	/^void Solver::toDimacs(FILE* f, const vec<Lit>& assumps)$/;"	f	class:Solver
toDimacs	solver/Solver.cc	/^void Solver::toDimacs(const char *file, const vec<Lit>& assumps)$/;"	f	class:Solver
toDimacs	solver/Solver.h	/^inline void     Solver::toDimacs     (const char* file){ vec<Lit> as; toDimacs(file, as); }$/;"	f	class:Minisat::Solver
toDimacs	solver/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p){ vec<Lit> as; as.push(p); toDimacs(file, as); }$/;"	f	class:Minisat::Solver
toDimacs	solver/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p, Lit q){ vec<Lit> as; as.push(p); as.push(q); toDimacs(file, as); }$/;"	f	class:Minisat::Solver
toDimacs	solver/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p, Lit q, Lit r){ vec<Lit> as; as.push(p); as.push(q); as.push(r); toDimacs(file, as); }$/;"	f	class:Minisat::Solver
toFileRs	solver/file.h	/^string toFileRs (char * filename){$/;"	f
toFile_ebg	camlside/file.h	/^string toFile_ebg (char * filename){$/;"	f
toFile_ebg	solver/file.h	/^string toFile_ebg (char * filename){$/;"	f
toFilein	camlside/file.h	/^string toFilein (char * filename){$/;"	f
toFilein	solver/file.h	/^string toFilein (char * filename){$/;"	f
toFileout	camlside/file.h	/^string toFileout (char * filename){$/;"	f
toFileout	solver/file.h	/^string toFileout (char * filename){$/;"	f
toInt	solver/SolverTypes.h	/^inline  int  toInt     (Lit p)              { return p.x; } $/;"	f	namespace:Minisat
toInt	solver/SolverTypes.h	/^inline  int  toInt     (Var v)              { return v; } $/;"	f	namespace:Minisat
toInt	solver/SolverTypes.h	/^inline int   toInt  (lbool l) { return l.value; }$/;"	f	namespace:Minisat
toIntList	camlside/Caml.ml	/^  let rec toIntList str = $/;"	v	Module:Caml
toIntList	solver/Caml.ml	/^  let rec toIntList str = $/;"	v	Module:Caml
toLbool	solver/SolverTypes.h	/^inline lbool toLbool(int   v) { return lbool((uint8_t)v);  }$/;"	f	namespace:Minisat
toLit	solver/SolverTypes.h	/^inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } $/;"	f	namespace:Minisat
toPrefix	camlside/Caml.ml	/^  let rec toPrefix  = function$/;"	v
toPrefix	solver/Caml.ml	/^  let rec toPrefix  = function$/;"	v
toString_ass	camlside/Caml.ml	/^  let rec toString_ass assign = match assign with$/;"	v	Module:Caml
toString_ass	solver/Caml.ml	/^  let rec toString_ass assign = match assign with$/;"	v	Module:Caml
toString_list	camlside/Caml.ml	/^   let rec toString_list = function$/;"	v
toString_list	solver/Caml.ml	/^   let rec toString_list = function$/;"	v
toString_lstIntv	camlside/Caml_Smt.ml	/^  let rec toString_lstIntv l = match l with$/;"	v
toString_lstIntv	solver/Caml.ml	/^  let rec toString_lstIntv l = match l with$/;"	v
token	camlside/SmtParser.ml	/^type token =$/;"	t
token	camlside/SmtParser.mli	/^type token =$/;"	t
token	camlside/parser.ml	/^type token =$/;"	t
token	camlside/parser.mli	/^type token =$/;"	t
tolist_bc	camlside/Caml_Smt.ml	/^  let rec tolist_bc l lb ub = match l with$/;"	v
tolist_bc	solver/Caml.ml	/^  let rec tolist_bc l lb ub = match l with$/;"	v
tot_literals	solver/Solver.h	/^    uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
totalClauses	camlside/Caml.ml	/^    let totalClauses = cl + iClause in $/;"	v
totalClauses	solver/Caml.ml	/^    let totalClauses = cl + iClause in $/;"	v
totalVars	camlside/Caml.ml	/^    let totalVars = 1 + 2* iLit * (sum_total_var 1 para) in$/;"	v
totalVars	solver/Caml.ml	/^    let totalVars = 1 + 2* iLit * (sum_total_var 1 para) in$/;"	v
trail	solver/Solver.h	/^    vec<Lit>            trail;            \/\/ Assignment stack; stores all assigments made in the order they were made.$/;"	m	class:Minisat::Solver
trail_lim	solver/Solver.h	/^    vec<int>            trail_lim;        \/\/ Separator indices for different decision levels in 'trail'.$/;"	m	class:Minisat::Solver
type_name	utils/Options.h	/^    const char* type_name;$/;"	m	class:Minisat::Option
uc_analysis	camlside/Caml.ml	/^  let rec uc_analysis fpos flist ia assIntv = match flist with$/;"	v
uc_analysis	solver/Caml.ml	/^  let rec uc_analysis fpos flist ia assIntv = match flist with$/;"	v
uc_extract	camlside/Caml.ml	/^  let rec uc_extract result initial l = match l with$/;"	v
uc_extract	solver/Caml.ml	/^  let rec uc_extract result initial l = match l with$/;"	v
uk_lit	camlside/Caml.ml	/^   let rec uk_lit l1 l2 = match l1 with$/;"	v
uk_lit	solver/Caml.ml	/^   let rec uk_lit l1 l2 = match l1 with$/;"	v
uk_reason	camlside/Caml.ml	/^  let rec uk_reason l1 l2 = match l1 with$/;"	v
uk_reason	solver/Caml.ml	/^  let rec uk_reason l1 l2 = match l1 with$/;"	v
uncheckedEnqueue	solver/Solver.cc	/^void Solver::uncheckedEnqueue(Lit p, CRef from)$/;"	f	class:Solver
unsat_test	camlside/Caml.ml	/^    let rec unsat_test e ass = match ass with$/;"	v
unsat_test	camlside/Caml.ml	/^  let rec unsat_test e ass = match ass with$/;"	v
unsat_test	solver/Caml.ml	/^    let rec unsat_test e ass = match ass with$/;"	v
unsat_test	solver/Caml.ml	/^  let rec unsat_test e ass = match ass with$/;"	v
update	mtl/Heap.h	/^    void update(int n)$/;"	f	class:Minisat::Heap
updateClause	camlside/file.h	/^int updateClause (char *filename, string newClause){$/;"	f
updateClause	solver/file.h	/^int updateClause (char *filename, string newClause){$/;"	f
update_bound	camlside/Caml_Smt.ml	/^let rec update_bound (x, lo, up, bCons) = match bCons with$/;"	v
update_bound	solver/Caml.ml	/^let rec update_bound (x, lo, up, bCons) = match bCons with$/;"	v
update_list	camlside/Caml_Smt.ml	/^  let rec update_list l l1 l2 = match l1 with$/;"	v
update_list	solver/Caml.ml	/^  let rec update_list l l1 l2 = match l1 with$/;"	v
update_var	camlside/Caml_Smt.ml	/^  let rec update_var (x, lb, ub) l = match l with$/;"	v
update_var	solver/Caml.ml	/^  let rec update_var (x, lb, ub) l = match l with$/;"	v
v	camlside/Expr.ml	/^        let (v,c) = Poly.min_binding p in $/;"	v
valSat	camlside/Caml.ml	/^    let rec valSat e ass= match e with$/;"	v
valSat	solver/Caml.ml	/^    let rec valSat e ass= match e with$/;"	v
valSat_all	camlside/Caml.ml	/^    let rec valSat_all e ass = match ass with$/;"	v
valSat_all	solver/Caml.ml	/^    let rec valSat_all e ass = match ass with$/;"	v
val_hi	camlside/IA.ml	/^	let val_hi = $/;"	v
value	solver/Solver.h	/^inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }$/;"	f	class:Minisat::Solver
value	solver/Solver.h	/^inline lbool    Solver::value         (Var x) const   { return assigns[x]; }$/;"	f	class:Minisat::Solver
value	solver/SolverTypes.h	/^    uint8_t value;$/;"	m	class:Minisat::lbool
value	utils/Options.h	/^    bool value;$/;"	m	class:Minisat::BoolOption
value	utils/Options.h	/^    const char* value;$/;"	m	class:Minisat::StringOption
value	utils/Options.h	/^    double      value;$/;"	m	class:Minisat::DoubleOption
value	utils/Options.h	/^    int32_t  value;$/;"	m	class:Minisat::IntOption
value	utils/Options.h	/^    int64_t  value;$/;"	m	class:Minisat::Int64Option
var	camlside/Expr.ml	/^type var = string $/;"	t
var	solver/SolverTypes.h	/^inline  int  var       (Lit p)              { return p.x >> 1; }$/;"	f	namespace:Minisat
varBumpActivity	solver/Solver.h	/^inline void Solver::varBumpActivity(Var v) { varBumpActivity(v, var_inc); }$/;"	f	class:Minisat::Solver
varBumpActivity	solver/Solver.h	/^inline void Solver::varBumpActivity(Var v, double inc) {$/;"	f	class:Minisat::Solver
varDecayActivity	solver/Solver.h	/^inline void Solver::varDecayActivity() { var_inc *= (1 \/ var_decay); }$/;"	f	class:Minisat::Solver
var_Undef	solver/SolverTypes.h	/^#define var_Undef /;"	d
var_bound	camlside/file.h	/^string var_bound (char *filename, int nvar){$/;"	f
var_bound	solver/file.h	/^string var_bound (char *filename, int nvar){$/;"	f
var_decay	solver/Solver.h	/^    double    var_decay;$/;"	m	class:Minisat::Solver
var_decomp	camlside/Caml.ml	/^  let var_decomp (var, ci) lstVarID code = $/;"	v
var_decomp	solver/Caml.ml	/^  let var_decomp (var, ci) lstVarID code = $/;"	v
var_decomp_neg	camlside/Caml.ml	/^  let var_decomp_neg (var, ci) lstVarID code esl = $/;"	v
var_decomp_neg	solver/Caml.ml	/^  let var_decomp_neg (var, ci) lstVarID code esl = $/;"	v
var_decomp_pn	camlside/Caml.ml	/^  let var_decomp_pn (var, ci) lstVarID code = $/;"	v
var_decomp_pn	solver/Caml.ml	/^  let var_decomp_pn (var, ci) lstVarID code = $/;"	v
var_decomp_pos	camlside/Caml.ml	/^  let var_decomp_pos (var, ci) lstVarID code esl = $/;"	v
var_decomp_pos	solver/Caml.ml	/^  let var_decomp_pos (var, ci) lstVarID code esl = $/;"	v
var_decomp_test_both	camlside/Caml.ml	/^  let var_decomp_test_both (var, ci) lstVarID code esl tc= $/;"	v
var_decomp_test_both	solver/Caml.ml	/^  let var_decomp_test_both (var, ci) lstVarID code esl tc= $/;"	v
var_decomp_test_neg	camlside/Caml.ml	/^  let var_decomp_test_neg (var, ci) lstVarID code esl tc= $/;"	v
var_decomp_test_neg	solver/Caml.ml	/^  let var_decomp_test_neg (var, ci) lstVarID code esl tc= $/;"	v
var_decomp_test_pos	camlside/Caml.ml	/^  let var_decomp_test_pos (var, ci) lstVarID code esl tc= $/;"	v
var_decomp_test_pos	solver/Caml.ml	/^  let var_decomp_test_pos (var, ci) lstVarID code esl tc= $/;"	v
var_exp	camlside/Caml.ml	/^  let var_exp e litID = $/;"	v	Module:Caml
var_exp	solver/Caml.ml	/^  let var_exp e litID = $/;"	v	Module:Caml
var_exp_list	camlside/Caml.ml	/^  let rec var_exp_list lst checkVarID = match lst with$/;"	v
var_exp_list	solver/Caml.ml	/^  let rec var_exp_list lst checkVarID = match lst with$/;"	v
var_inc	solver/Solver.h	/^    double              var_inc;          \/\/ Amount to bump next variable with.$/;"	m	class:Minisat::Solver
var_list	camlside/Caml.ml	/^  let rec var_list lstCheck iVar lstIDLit = match lstCheck with$/;"	v
var_list	solver/Caml.ml	/^  let rec var_list lstCheck iVar lstIDLit = match lstCheck with$/;"	v
vardata	solver/Solver.h	/^    vec<VarData>        vardata;          \/\/ Stores reason and level for each variable.$/;"	m	class:Minisat::Solver
variable	camlside/Expr.ml	/^  let variable v = Poly.singleton [v] 1. $/;"	v	Module:Expr
vars_in_tc	camlside/Caml.ml	/^  let rec vars_in_tc tc = match tc with$/;"	v
vars_in_tc	solver/Caml.ml	/^  let rec vars_in_tc tc = match tc with$/;"	v
vars_unbind	camlside/Caml.ml	/^  let rec vars_unbind l = match l with$/;"	v
vars_unbind	solver/Caml.ml	/^  let rec vars_unbind l = match l with$/;"	v
vec	mtl/Vec.h	/^             vec        (vec<T>& other) { assert(0); }$/;"	f	class:Minisat::vec
vec	mtl/Vec.h	/^    explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }$/;"	f	class:Minisat::vec
vec	mtl/Vec.h	/^    vec()                       : data(NULL) , sz(0)   , cap(0)    { }$/;"	f	class:Minisat::vec
vec	mtl/Vec.h	/^    vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }$/;"	f	class:Minisat::vec
vec	mtl/Vec.h	/^class vec {$/;"	c	namespace:Minisat
verbosity	solver/Solver.h	/^    int       verbosity;$/;"	m	class:Minisat::Solver
wasted	mtl/Alloc.h	/^    uint32_t wasted    () const      { return wasted_; }$/;"	f	class:Minisat::RegionAllocator
wasted_	mtl/Alloc.h	/^    uint32_t  wasted_;$/;"	m	class:Minisat::RegionAllocator
watches	solver/Solver.h	/^                        watches;          \/\/ 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).$/;"	m	class:Minisat::Solver
withinBudget	solver/Solver.h	/^inline bool     Solver::withinBudget() const {$/;"	f	class:Minisat::Solver
writeFile	camlside/file.h	/^int writeFile (char *filename, string content){$/;"	f
writeFile	solver/file.h	/^int writeFile (char *filename, string content){$/;"	f
x	solver/SolverTypes.h	/^    int     x;$/;"	m	struct:Minisat::Lit
x1	camlside/Caml_Smt.ml	/^      let (x1, lo1, up1) = update_bound (x, lo, up, e1) in$/;"	v
x1	solver/Caml.ml	/^      let (x1, lo1, up1) = update_bound (x, lo, up, e1) in$/;"	v
xrealloc	mtl/XAlloc.h	/^static inline void* xrealloc(void *ptr, size_t size)$/;"	f	namespace:Minisat
yyact	camlside/SmtParser.ml	/^let yyact = [|$/;"	v
yyact	camlside/parser.ml	/^let yyact = [|$/;"	v
yycheck	camlside/SmtParser.ml	/^let yycheck = "\\010\\000\\$/;"	v
yycheck	camlside/parser.ml	/^let yycheck = "\\019\\000\\$/;"	v
yydefred	camlside/SmtParser.ml	/^let yydefred = "\\000\\000\\$/;"	v
yydefred	camlside/parser.ml	/^let yydefred = "\\000\\000\\$/;"	v
yydgoto	camlside/SmtParser.ml	/^let yydgoto = "\\002\\000\\$/;"	v
yydgoto	camlside/parser.ml	/^let yydgoto = "\\002\\000\\$/;"	v
yygindex	camlside/SmtParser.ml	/^let yygindex = "\\000\\000\\$/;"	v
yygindex	camlside/parser.ml	/^let yygindex = "\\000\\000\\$/;"	v
yylen	camlside/SmtParser.ml	/^let yylen = "\\002\\000\\$/;"	v
yylen	camlside/parser.ml	/^let yylen = "\\002\\000\\$/;"	v
yylhs	camlside/SmtParser.ml	/^let yylhs = "\\255\\255\\$/;"	v
yylhs	camlside/parser.ml	/^let yylhs = "\\255\\255\\$/;"	v
yynames_block	camlside/SmtParser.ml	/^let yynames_block = "\\$/;"	v
yynames_block	camlside/parser.ml	/^let yynames_block = "\\$/;"	v
yynames_const	camlside/SmtParser.ml	/^let yynames_const = "\\$/;"	v
yynames_const	camlside/parser.ml	/^let yynames_const = "\\$/;"	v
yyrindex	camlside/SmtParser.ml	/^let yyrindex = "\\000\\000\\$/;"	v
yyrindex	camlside/parser.ml	/^let yyrindex = "\\000\\000\\$/;"	v
yysindex	camlside/SmtParser.ml	/^let yysindex = "\\013\\000\\$/;"	v
yysindex	camlside/parser.ml	/^let yysindex = "\\007\\000\\$/;"	v
yytable	camlside/SmtParser.ml	/^let yytable = "\\027\\000\\$/;"	v
yytable	camlside/parser.ml	/^let yytable = "\\043\\000\\$/;"	v
yytablesize	camlside/SmtParser.ml	/^let yytablesize = 288$/;"	v
yytablesize	camlside/parser.ml	/^let yytablesize = 66$/;"	v
yytransl_block	camlside/SmtParser.ml	/^let yytransl_block = [|$/;"	v
yytransl_block	camlside/parser.ml	/^let yytransl_block = [|$/;"	v
yytransl_const	camlside/SmtParser.ml	/^let yytransl_const = [|$/;"	v
yytransl_const	camlside/parser.ml	/^let yytransl_const = [|$/;"	v
~Map	mtl/Map.h	/^    ~Map () { delete [] table; }$/;"	f	class:Minisat::Map
~Option	utils/Options.h	/^    virtual ~Option() {}$/;"	f	class:Minisat::Option
~RegionAllocator	mtl/Alloc.h	/^    ~RegionAllocator()$/;"	f	class:Minisat::RegionAllocator
~Solver	solver/Solver.cc	/^Solver::~Solver()$/;"	f	class:Solver
~vec	mtl/Vec.h	/^   ~vec()                                                          { clear(true); }$/;"	f	class:Minisat::vec
