!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
*	IA.ml	/^    let ( * ) (i1: inf_interval) (i2: inf_interval) = i1 #mul i2 $/;"	f	Module:ICI
*	IA.ml	/^    let ( * ) (i1: interval) (i2: interval) = i1 #mul i2 $/;"	f	Module:CI
*	IA.ml	/^    let ( * ) (t1: af1) (t2: af1) = t1 #mul t2$/;"	f	Module:AF1
*	IA.ml	/^    let ( * ) (t1: af2) (t2: af2) = t1 #mul t2$/;"	f	Module:AF2
*	IA.ml	/^    let ( * ) (t1: caf2) (t2: caf2) = t1 #mul t2$/;"	f	Module:CAF2
*	IA.ml	/^    let ( * ) (t1: cai1) (t2: cai1) = t1 #mul t2$/;"	f	Module:CAI1
*	IA.ml	/^    let ( * ) (t1: cai2) (t2: cai2)   = t1 #mul t2$/;"	f	Module:CAI2
*	IA.ml	/^    let ( * ) (t1: cai3) (t2: cai3) = t1 #mul t2$/;"	f	Module:CAI3
*@	IA.ml	/^    let ( *@ )(c: float)(t: af1)  = t #mul2 c$/;"	f	Module:AF1
*@	IA.ml	/^    let ( *@) (c: float)         (i: inf_interval)  = i #mul2 c$/;"	f	Module:ICI
*@	IA.ml	/^    let ( *@) (c: float)     (i: interval)  = i #mul2 c$/;"	f	Module:CI
*@	IA.ml	/^    let ( *@) (c: float) (t: cai3)  = t #mul2 c$/;"	f	Module:CAI3
*@	IA.ml	/^    let ( *@) (c: float)(t: af2)  = t #mul2 c$/;"	f	Module:AF2
*@	IA.ml	/^    let ( *@) (c: float)(t: caf2)  = t #mul2 c$/;"	f	Module:CAF2
*@	IA.ml	/^    let ( *@) (c: float)(t: cai1)  = t #mul2 c$/;"	f	Module:CAI1
*@	IA.ml	/^    let ( *@) (c:float)(t: cai2)    = t #mul_cons (new interval c c)$/;"	f	Module:CAI2
+	IA.ml	/^    let ( + ) (i1: inf_interval) (i2: inf_interval) = i1 #add i2$/;"	f	Module:ICI
+	IA.ml	/^    let ( + ) (i1: interval) (i2: interval) = i1 #add i2$/;"	f	Module:CI
+	IA.ml	/^    let ( + ) (t1: af1) (t2: af1) = t1 #add t2$/;"	f	Module:AF1
+	IA.ml	/^    let ( + ) (t1: af2) (t2: af2) = t1 #add t2$/;"	f	Module:AF2
+	IA.ml	/^    let ( + ) (t1: caf2) (t2: caf2) = t1 #add t2$/;"	f	Module:CAF2
+	IA.ml	/^    let ( + ) (t1: cai1) (t2: cai1) = t1 #add t2$/;"	f	Module:CAI1
+	IA.ml	/^    let ( + ) (t1: cai2) (t2: cai2)   = t1 #add t2$/;"	f	Module:CAI2
+	IA.ml	/^    let ( + ) (t1: cai3) (t2: cai3) = t1 #add t2$/;"	f	Module:CAI3
+@	IA.ml	/^    let ( +@) (i: inf_interval)  (c: float)         = i #add2 c$/;"	f	Module:ICI
+@	IA.ml	/^    let ( +@) (i: interval)  (c: float)     = i #add2 c$/;"	f	Module:CI
+@	IA.ml	/^    let ( +@) (t: af1)  (c: float)= t #add2 c$/;"	f	Module:AF1
+@	IA.ml	/^    let ( +@) (t: af2)  (c: float)= t #add2 c$/;"	f	Module:AF2
+@	IA.ml	/^    let ( +@) (t: caf2)  (c: float)= t #add2 c$/;"	f	Module:CAF2
+@	IA.ml	/^    let ( +@) (t: cai1)  (c: float)= t #add2 c$/;"	f	Module:CAI1
+@	IA.ml	/^    let ( +@) (t: cai2)  (c: float) = t #add2 c$/;"	f	Module:CAI2
+@	IA.ml	/^    let ( +@) (t: cai3)  (c: float) = t #add2 c$/;"	f	Module:CAI3
-	IA.ml	/^    let ( - ) (i1: inf_interval) (i2: inf_interval) = i1 #sub i2   $/;"	f	Module:ICI
-	IA.ml	/^    let ( - ) (i1: interval) (i2: interval) = i1 #sub i2   $/;"	f	Module:CI
-	IA.ml	/^    let ( - ) (t1: af1) (t2: af1) = t1 #sub t2$/;"	f	Module:AF1
-	IA.ml	/^    let ( - ) (t1: af2) (t2: af2) = t1 #sub t2$/;"	f	Module:AF2
-	IA.ml	/^    let ( - ) (t1: caf2) (t2: caf2) = t1 #sub t2$/;"	f	Module:CAF2
-	IA.ml	/^    let ( - ) (t1: cai1) (t2: cai1) = t1 #sub t2$/;"	f	Module:CAI1
-	IA.ml	/^    let ( - ) (t1: cai2) (t2: cai2)   = t1 #sub t2$/;"	f	Module:CAI2
-	IA.ml	/^    let ( - ) (t1: cai3) (t2: cai3)  = t1 #sub t2$/;"	f	Module:CAI3
-@	IA.ml	/^    let ( -@ )(t: af1)  (c: float)= t #sub2 c$/;"	f	Module:AF1
-@	IA.ml	/^    let ( -@ )(t: cai1)  (c: float)= t #sub2 c$/;"	f	Module:CAI1
-@	IA.ml	/^    let ( -@ )(t: cai2)  (c: float) = t #sub2 c$/;"	f	Module:CAI2
-@	IA.ml	/^    let ( -@) (i: inf_interval)  (c: float)         = i #sub2 c  $/;"	f	Module:ICI
-@	IA.ml	/^    let ( -@) (i: interval)  (c: float)     = i #sub2 c   $/;"	f	Module:CI
-@	IA.ml	/^    let ( -@) (t: af2)  (c: float)= t #sub2 c$/;"	f	Module:AF2
-@	IA.ml	/^    let ( -@) (t: caf2)  (c: float)= t #sub2 c$/;"	f	Module:CAF2
-@	IA.ml	/^    let ( -@) (t: cai3)  (c: float) = t #sub2 c$/;"	f	Module:CAI3
<	IA.ml	/^    let ( < ) (i1: bound) (i2: bound) = le i1 i2  $/;"	f	Module:ICI
<=	IA.ml	/^    let ( <= )(i1: bound) (i2: bound) = leq i1 i2 $/;"	f	Module:ICI
==	IA.ml	/^    let ( == )(i1: bound) (i2: bound) = eq i1 i2  $/;"	f	Module:ICI
>	IA.ml	/^    let ( > ) (i1: bound) (i2: bound) = ge i1 i2  $/;"	f	Module:ICI
>=	IA.ml	/^    let ( >= )(i1: bound) (i2: bound) = geq i1 i2  $/;"	f	Module:ICI
AF1	IA.ml	/^  module AF1 = struct$/;"	M
AF1	file.h	/^const int AF1  = 2;              \/\/Affine Form of interval 1$/;"	v
AF2	IA.ml	/^  module AF2 = struct$/;"	M
AF2	file.h	/^const int AF2  = 3;              \/\/Affine Form of interval 2$/;"	v
AND	Caml_Smt.ml	/^  | AND of nil_expr * nil_expr $/;"	C	type:Caml/nil_expr
AND	SmtParser.ml	/^  | AND$/;"	C	type:token
AND	SmtParser.mli	/^  | AND$/;"	C	type:token
AND	parser.ml	/^  | AND$/;"	C	type:token
AND	parser.mli	/^  | AND$/;"	C	type:token
ASSERT	SmtParser.ml	/^  | ASSERT$/;"	C	type:token
ASSERT	SmtParser.mli	/^  | ASSERT$/;"	C	type:token
ASSERT	parser.ml	/^  | ASSERT$/;"	C	type:token
ASSERT	parser.mli	/^  | ASSERT$/;"	C	type:token
Add	Exp.ml	/^  | Add of smt_poly_expr * smt_poly_expr $/;"	C	type:smt_poly_expr
Add	ast.ml	/^  | Add of poly_expr * poly_expr $/;"	C	type:poly_expr
And	Exp.ml	/^  | And of smt_bool_expr * smt_bool_expr$/;"	C	type:smt_bool_expr
And	ast.ml	/^  | And of bool_expr * bool_expr$/;"	C	type:bool_expr
As	Exp.ml	/^  | As of let_expr * ass_expr$/;"	C	type:ass_expr
Ass	ast.ml	/^  | Ass of bool_expr$/;"	C	type:formula
Ast	ast.ml	/^(*raSAT expression*)$/;"	M
BC	Caml_Smt.ml	/^  | BC of smt_bool_expr$/;"	C	type:Caml/nil_expr
BEq	Exp.ml	/^  | BEq of string * smt_bool_expr$/;"	C	type:let_expr
BVar	Exp.ml	/^  | BVar of string$/;"	C	type:smt_bool_expr
CAF	file.h	/^const int CAF  = 4;              \/\/Chebyshev Affine Form of interval $/;"	v
CAF2	IA.ml	/^  module CAF2 = struct$/;"	M
CAI1	IA.ml	/^  module CAI1 = struct$/;"	M
CAI2	IA.ml	/^  module CAI2 = struct$/;"	M
CAI3	IA.ml	/^  module CAI3 = struct$/;"	M
CC	Makefile	/^CC=g++$/;"	m
CI	IA.ml	/^  module CI = struct$/;"	M
CI	file.h	/^const int CI   = 1;              \/\/Classical Interval$/;"	v
CONJ	SmtParser.ml	/^  | CONJ$/;"	C	type:token
CONJ	SmtParser.mli	/^  | CONJ$/;"	C	type:token
Caml	Caml.ml	/^module Caml = struct$/;"	M
Caml	Caml.ml	/^open Ast           (*type: literal, clause, formula... declaration*)   $/;"	M
Caml	Caml_Smt.ml	/^module Caml = struct$/;"	M
Caml_Smt	Caml_Smt.ml	/^open Exp           (*type: literal, clause, formula... declaration*)   $/;"	M
Ch	Exp.ml	/^  | Ch of smt_bool_expr$/;"	C	type:ass_expr
Cl	ast.ml	/^  | Cl of intv_clause$/;"	C	type:intv_expr
Conj	Exp.ml	/^  | Conj of ass_expr * ass_expr$/;"	C	type:ass_expr
DIV	SmtParser.ml	/^  | DIV$/;"	C	type:token
DIV	SmtParser.mli	/^  | DIV$/;"	C	type:token
Div	Exp.ml	/^  | Div of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_poly_expr
EOF	SmtParser.ml	/^  | EOF$/;"	C	type:token
EOF	SmtParser.mli	/^  | EOF$/;"	C	type:token
EOF	parser.ml	/^  | EOF$/;"	C	type:token
EOF	parser.mli	/^  | EOF$/;"	C	type:token
EQ	SmtParser.ml	/^  | EQ$/;"	C	type:token
EQ	SmtParser.mli	/^  | EQ$/;"	C	type:token
EQ	parser.ml	/^  | EQ$/;"	C	type:token
EQ	parser.mli	/^  | EQ$/;"	C	type:token
Eq	Exp.ml	/^  | Eq of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_bool_expr
Eq	ast.ml	/^  | Eq of poly_expr * poly_expr$/;"	C	type:bool_expr
Exp	Exp.ml	/^(*SMT expression*)$/;"	M
Expr	Expr.ml	/^module Expr = struct$/;"	M
Expr	Expr.ml	/^open Exp$/;"	M
Float	IA.ml	/^  type bound = Float of float | Neg_inf | Pos_inf$/;"	C	type:IA/bound
GEQ	SmtParser.ml	/^  | GEQ$/;"	C	type:token
GEQ	SmtParser.mli	/^  | GEQ$/;"	C	type:token
GEQ	parser.ml	/^  | GEQ$/;"	C	type:token
GEQ	parser.mli	/^  | GEQ$/;"	C	type:token
GR	SmtParser.ml	/^  | GR$/;"	C	type:token
GR	SmtParser.mli	/^  | GR$/;"	C	type:token
GR	parser.ml	/^  | GR$/;"	C	type:token
GR	parser.mli	/^  | GR$/;"	C	type:token
Geq	Exp.ml	/^  | Geq of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_bool_expr
Geq	ast.ml	/^  | Geq of poly_expr * poly_expr$/;"	C	type:bool_expr
Gr	Exp.ml	/^  | Gr of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_bool_expr
Gr	ast.ml	/^  | Gr of poly_expr * poly_expr$/;"	C	type:bool_expr
IA	IA.ml	/^module IA = struct$/;"	M
IC	parser.ml	/^  | IC$/;"	C	type:token
IC	parser.mli	/^  | IC$/;"	C	type:token
ICI	IA.ml	/^  module ICI = struct$/;"	M
ID	SmtParser.ml	/^  | ID of (string)$/;"	C	type:token
ID	SmtParser.mli	/^  | ID of (string)$/;"	C	type:token
ID	parser.ml	/^  | ID of (string)$/;"	C	type:token
ID	parser.mli	/^  | ID of (string)$/;"	C	type:token
IN	parser.ml	/^  | IN$/;"	C	type:token
IN	parser.mli	/^  | IN$/;"	C	type:token
Ic	ast.ml	/^  | Ic of intv_expr * intv_expr            (*Ic: Interval constraints *)$/;"	C	type:intv_expr
In	ast.ml	/^  | In of string * float * float$/;"	C	type:intv_clause
Intv	ast.ml	/^  | Intv of intv_expr  $/;"	C	type:formula
LE	SmtParser.ml	/^  | LE$/;"	C	type:token
LE	SmtParser.mli	/^  | LE$/;"	C	type:token
LE	parser.ml	/^  | LE$/;"	C	type:token
LE	parser.mli	/^  | LE$/;"	C	type:token
LEQ	SmtParser.ml	/^  | LEQ$/;"	C	type:token
LEQ	SmtParser.mli	/^  | LEQ$/;"	C	type:token
LEQ	parser.ml	/^  | LEQ$/;"	C	type:token
LEQ	parser.mli	/^  | LEQ$/;"	C	type:token
LET	SmtParser.ml	/^  | LET$/;"	C	type:token
LET	SmtParser.mli	/^  | LET$/;"	C	type:token
LPAREN	SmtParser.ml	/^  | LPAREN$/;"	C	type:token
LPAREN	SmtParser.mli	/^  | LPAREN$/;"	C	type:token
LPAREN	parser.ml	/^  | LPAREN$/;"	C	type:token
LPAREN	parser.mli	/^  | LPAREN$/;"	C	type:token
Le	Exp.ml	/^  | Le of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_bool_expr
Le	ast.ml	/^  | Le of poly_expr * poly_expr$/;"	C	type:bool_expr
Leq	Exp.ml	/^  | Leq of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_bool_expr
Leq	ast.ml	/^  | Leq of poly_expr * poly_expr$/;"	C	type:bool_expr
Let	Exp.ml	/^  | Let of let_expr * let_expr$/;"	C	type:let_expr
Lexer	lexer.ml	/^# 1 "lexer.mll"$/;"	M
MINUS	SmtParser.ml	/^  | MINUS$/;"	C	type:token
MINUS	SmtParser.mli	/^  | MINUS$/;"	C	type:token
MINUS	parser.ml	/^  | MINUS$/;"	C	type:token
MINUS	parser.mli	/^  | MINUS$/;"	C	type:token
Mul	Exp.ml	/^  | Mul of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_poly_expr
Mul	ast.ml	/^  | Mul of poly_expr * poly_expr$/;"	C	type:poly_expr
MultiVar	Expr.ml	/^module MultiVar = struct $/;"	M
NOT	SmtParser.ml	/^  | NOT$/;"	C	type:token
NOT	SmtParser.mli	/^  | NOT$/;"	C	type:token
NUM	SmtParser.ml	/^  | NUM of (string)$/;"	C	type:token
NUM	SmtParser.mli	/^  | NUM of (string)$/;"	C	type:token
NUM	parser.ml	/^  | NUM of (string)$/;"	C	type:token
NUM	parser.mli	/^  | NUM of (string)$/;"	C	type:token
Neg_inf	IA.ml	/^  type bound = Float of float | Neg_inf | Pos_inf$/;"	C	type:IA/bound
Nil	Caml_Smt.ml	/^  | Nil$/;"	C	type:Caml/nil_expr
Not	Exp.ml	/^  | Not of smt_bool_expr$/;"	C	type:smt_bool_expr
OC	Makefile	/^OC=ocamlopt$/;"	m
OCAML_LIB	Makefile	/^OCAML_LIB=camllib.a$/;"	m
OR	SmtParser.ml	/^  | OR$/;"	C	type:token
OR	SmtParser.mli	/^  | OR$/;"	C	type:token
OR	parser.ml	/^  | OR$/;"	C	type:token
OR	parser.mli	/^  | OR$/;"	C	type:token
Or	ast.ml	/^  | Or of intv_clause * intv_clause                $/;"	C	type:intv_clause
PEq	Exp.ml	/^  | PEq of string * smt_poly_expr$/;"	C	type:let_expr
PLUS	SmtParser.ml	/^  | PLUS$/;"	C	type:token
PLUS	SmtParser.mli	/^  | PLUS$/;"	C	type:token
PLUS	parser.ml	/^  | PLUS$/;"	C	type:token
PLUS	parser.mli	/^  | PLUS$/;"	C	type:token
POWER	SmtParser.ml	/^  | POWER$/;"	C	type:token
POWER	SmtParser.mli	/^  | POWER$/;"	C	type:token
POWER	parser.ml	/^  | POWER$/;"	C	type:token
POWER	parser.mli	/^  | POWER$/;"	C	type:token
Parser	parser.ml	/^type token =$/;"	M
Parser	parser.mli	/^type token =$/;"	M
Poly	Expr.ml	/^module Poly = Map.Make(MultiVar) $/;"	M
Pos_inf	IA.ml	/^  type bound = Float of float | Neg_inf | Pos_inf$/;"	C	type:IA/bound
Pow	Exp.ml	/^  | Pow of smt_poly_expr * int$/;"	C	type:smt_poly_expr
Pow	ast.ml	/^  | Pow of poly_expr * int$/;"	C	type:poly_expr
RESULT	Makefile	/^RESULT = a$/;"	m
RPAREN	SmtParser.ml	/^  | RPAREN$/;"	C	type:token
RPAREN	SmtParser.mli	/^  | RPAREN$/;"	C	type:token
RPAREN	parser.ml	/^  | RPAREN$/;"	C	type:token
RPAREN	parser.mli	/^  | RPAREN$/;"	C	type:token
Real	Exp.ml	/^  | Real of float$/;"	C	type:smt_poly_expr
Real	ast.ml	/^  | Real of float$/;"	C	type:poly_expr
SOURCES	Makefile	/^SOURCES = ast.ml parser.mly lexer.mll Exp.ml SmtParser.mly SmtLexer.mll Expr.ml IA.ml Util.ml str.cma Caml.ml Caml_Smt.ml$/;"	m
SUBVAR	SmtParser.ml	/^  | SUBVAR of (string)$/;"	C	type:token
SUBVAR	SmtParser.mli	/^  | SUBVAR of (string)$/;"	C	type:token
SmtLexer	SmtLexer.ml	/^# 1 "SmtLexer.mll"$/;"	M
SmtParser	SmtParser.ml	/^type token =$/;"	M
SmtParser	SmtParser.mli	/^type token =$/;"	M
Sub	Exp.ml	/^  | Sub of smt_poly_expr * smt_poly_expr$/;"	C	type:smt_poly_expr
Sub	ast.ml	/^  | Sub of poly_expr * poly_expr$/;"	C	type:poly_expr
SubVar	Exp.ml	/^  | SubVar of string$/;"	C	type:smt_poly_expr
TIMES	SmtParser.ml	/^  | TIMES$/;"	C	type:token
TIMES	SmtParser.mli	/^  | TIMES$/;"	C	type:token
TIMES	parser.ml	/^  | TIMES$/;"	C	type:token
TIMES	parser.mli	/^  | TIMES$/;"	C	type:token
Util	Util.ml	/^module Util = struct$/;"	M
Util	Util.ml	/^open IA;;$/;"	M
Var	Exp.ml	/^  | Var of string$/;"	C	type:smt_poly_expr
Var	ast.ml	/^  | Var of string$/;"	C	type:poly_expr
^	IA.ml	/^    let ( ^ ) (t: af1 ) (n: int)  = pow t n    $/;"	f	Module:AF1
^	IA.ml	/^    let ( ^ ) (t: af2)  (n: int)  = pow t n$/;"	f	Module:AF2
^	IA.ml	/^    let ( ^ ) (t: caf2)  (n: int)  = pow t n$/;"	f	Module:CAF2
^	IA.ml	/^    let ( ^ ) (t: cai1)  (n: int)  = pow t n$/;"	f	Module:CAI1
^	IA.ml	/^    let ( ^ ) (t: cai2)  (n: int)   = pow t n$/;"	f	Module:CAI2
^	IA.ml	/^    let ( ^ ) (t: cai3)  (n: int)   = pow t n$/;"	f	Module:CAI3
^	IA.ml	/^    let ( ^)  (i: inf_interval)  (n: int)           = i #pow n    $/;"	f	Module:ICI
^	IA.ml	/^    let ( ^)  (i: interval)  (n: int)       = i #pow n    $/;"	f	Module:CI
a	IA.ml	/^      method a = a$/;"	m	class:af1
a	IA.ml	/^      method a = a$/;"	m	class:af2
a	IA.ml	/^      method a = a$/;"	m	class:caf2
a	IA.ml	/^      method a = a$/;"	m	class:cai1
a	IA.ml	/^      method a = a$/;"	m	class:cai2
a	IA.ml	/^      method a = a$/;"	m	class:cai3
a	IA.ml	/^      val mutable a  = (new interval 0.0 0.0: interval)   (*coeff of free var*)$/;"	v	class:caf2
a	IA.ml	/^      val mutable a  = (new interval 0.0 0.0: interval)   (*coeff of free var*)$/;"	v	class:cai1
a	IA.ml	/^      val mutable a  = (new interval 0.0 0.0: interval)   (*coeff of free var*)$/;"	v	class:cai2
a	IA.ml	/^      val mutable a  = (new interval 0.0 0.0: interval)   (*coeff of free var*)$/;"	v	class:cai3
a	IA.ml	/^      val mutable a = (0.0: float)   (*coeff of free var*)$/;"	v	class:af2
a	IA.ml	/^      val mutable a = (0.0: float)  (*coeff of free var*)$/;"	v	class:af1
abs_float	Caml_Smt.ml	/^let abs_float (num: float) =$/;"	v	Module:Caml
add	IA.ml	/^      method add (other: af1) = $/;"	m	class:af1
add	IA.ml	/^      method add (other: af2) = $/;"	m	class:af2
add	IA.ml	/^      method add (other: caf2) = 	$/;"	m	class:caf2
add	IA.ml	/^      method add (other: cai1) = 	$/;"	m	class:cai1
add	IA.ml	/^      method add (other: cai2) = 	$/;"	m	class:cai2
add	IA.ml	/^      method add (other: cai3) = 	$/;"	m	class:cai3
add	IA.ml	/^      method add (other: interval)= $/;"	m	class:interval
add2	IA.ml	/^      method add2 (c: float) = $/;"	m	class:af1
add2	IA.ml	/^      method add2 (c: float) = $/;"	m	class:af2
add2	IA.ml	/^      method add2 (c: float) = $/;"	m	class:caf2
add2	IA.ml	/^      method add2 (c: float) = $/;"	m	class:cai1
add2	IA.ml	/^      method add2 (c: float) = $/;"	m	class:cai2
add2	IA.ml	/^      method add2 (c: float) = $/;"	m	class:cai3
add2	IA.ml	/^      method add2 (c: float)= $/;"	m
add2	IA.ml	/^      method add2 (c: float)= $/;"	m	class:interval
af1	IA.ml	/^  class af1 size = object (self)$/;"	c
af2	IA.ml	/^  class af2 size = object (self)$/;"	c
allLog	Caml.ml	/^  let rec allLog e ia assIntv = match e with$/;"	v
ar	IA.ml	/^      method ar = ar$/;"	m	class:af1
ar	IA.ml	/^      method ar = ar$/;"	m	class:af2
ar	IA.ml	/^      method ar = ar$/;"	m	class:caf2
ar	IA.ml	/^      method ar = ar$/;"	m	class:cai1
ar	IA.ml	/^      method ar = ar$/;"	m	class:cai2
ar	IA.ml	/^      method ar = ar$/;"	m	class:cai3
assIntv	Caml.ml	/^      let assIntv = ci_ass lstCheck iVar lstIDLit in$/;"	v
ass_decomp	Caml.ml	/^  let rec ass_decomp ass lstVarID code esl = match ass with$/;"	v
ass_decomp_neg	Caml.ml	/^  let rec ass_decomp_neg ass lstVarID code esl = match ass with$/;"	v
ass_decomp_pn	Caml.ml	/^  let rec ass_decomp_pn ass lstVarID code esl = match ass with$/;"	v
ass_decomp_pos	Caml.ml	/^  let rec ass_decomp_pos ass lstVarID code esl = match ass with$/;"	v
ass_decomp_test_both	Caml.ml	/^  let rec ass_decomp_test_both ass lstVarID code esl tc = match ass with$/;"	v
ass_decomp_test_neg	Caml.ml	/^  let rec ass_decomp_test_neg ass lstVarID code esl tc = match ass with$/;"	v
ass_decomp_test_pos	Caml.ml	/^  let rec ass_decomp_test_pos ass lstVarID code esl tc = match ass with$/;"	v
ass_expr	Exp.ml	/^type ass_expr = $/;"	t
bool_expr	ast.ml	/^type bool_expr = $/;"	t
bool_reduce	Caml_Smt.ml	/^let rec bool_reduce = function$/;"	v
bool_simp	Caml_Smt.ml	/^let rec bool_simp = function$/;"	v
bool_toList	Caml_Smt.ml	/^  let rec bool_toList e = match e with$/;"	v
bool_toPrefix	Caml_Smt.ml	/^let rec bool_toPrefix = function$/;"	v
bool_toString	Caml.ml	/^let rec bool_toString = function$/;"	v	Module:Caml
bool_toString	Caml_Smt.ml	/^let rec bool_toString = function$/;"	v
bool_vars	Caml.ml	/^  let rec bool_vars e = $/;"	v	Module:Caml
bound	IA.ml	/^  type bound = Float of float | Neg_inf | Pos_inf$/;"	t	Module:IA
bound_step	file.h	/^double bound_step (char *filename){$/;"	f
bound_toPrefix	Caml_Smt.ml	/^let rec bound_toPrefix = function$/;"	v
bound_var	Caml.ml	/^  let bound_var (x, it) = x ^ " = " ^ "[" ^ (string_of_float it#l) ^ "," ^ (string_of_float it#h) ^ "]"$/;"	v	Module:Caml
build_ass	Caml.ml	/^  let rec build_ass eList lstVar = match eList with$/;"	v
caf2	IA.ml	/^  class caf2 (size: int) = object (self)$/;"	c
cai1	IA.ml	/^  class cai1 (size: int) = object (self)$/;"	c
cai2	IA.ml	/^  class cai2 (size: int) = object (self)$/;"	c
cai3	IA.ml	/^  class cai3 (size: int) = object (self)$/;"	c
caml_InfCheck	modwrap.cc	/^int caml_InfCheck(char * sIntv, char* sAss){$/;"	f
caml_doTest	modwrap.cc	/^value caml_doTest (char *sIntv, char *sCons, char *sCheck, int ia){$/;"	f
caml_dynTest	modwrap.cc	/^value caml_dynTest (char *sIntv, char* dIntv, char *sCons, char *sCheck, int ia, double esl, char *sTestUS){$/;"	f
caml_genSatForm	modwrap.cc	/^value caml_genSatForm(char * sIntv, double esl)$/;"	f
caml_genSmtForm	modwrap.cc	/^value caml_genSmtForm(char * sIntv, char *sAssert, double lb, double ub)$/;"	f
caml_getNumCons	modwrap.cc	/^int caml_getNumCons(char * sAss)$/;"	f
caml_isTheoConsis	modwrap.cc	/^value caml_isTheoConsis (char *sIntv, char *sCons, char *sCheck, int ia){$/;"	f
caml_logResult	modwrap.cc	/^char* caml_logResult(char * sIntv, char *sCons, char *sCheck, int ia)$/;"	f
checkSat	Caml.ml	/^  let checkSat e ia assIntv = $/;"	v
checkValue	Caml.ml	/^  let checkValue e ass = $/;"	v
checkValue1	Caml.ml	/^  let checkValue1 e ass = $/;"	v
checkVarID	Caml.ml	/^      let checkVarID = var_list lstCheck iVar lstIDLit in      $/;"	v
ci_ass	Caml.ml	/^  let rec ci_ass lstCheck iVar lstIDLit = match lstCheck with$/;"	v
cl	Caml.ml	/^    let (cl, sCnfCons) = genCnfCons eIntv in$/;"	v
cl_count	Caml.ml	/^  let rec cl_count e = match e with $/;"	v	Module:Caml
cl_infAssign	Caml.ml	/^  let rec cl_infAssign exp = match exp with$/;"	v
cl_toLit	Caml.ml	/^  let rec cl_toLit = function$/;"	v	Module:Caml
cnf_all	Caml.ml	/^  let rec cnf_all = function 				$/;"	v	Module:Caml
cnf_clause	Caml.ml	/^  let rec cnf_clause = function$/;"	v	Module:Caml
cnf_list	Caml.ml	/^  let rec cnf_list a l = match l with$/;"	v	Module:Caml
collect	Caml.ml	/^  let rec collect exp e = match e with$/;"	v
com_list	Caml_Smt.ml	/^let rec com_list l1 l2 = match l1 with$/;"	v
compare	Expr.ml	/^    let compare = Pervasives.compare $/;"	v	Module:MultiVar
compare_cons	Caml.ml	/^  let compare_cons e1 e2 = $/;"	v
constant	Expr.ml	/^  let constant x = Poly.singleton [] x $/;"	v	Module:Expr
decomp	Caml.ml	/^  let decomp l = f4 [] l$/;"	v
decomp_reduce	Caml.ml	/^  let rec decomp_reduce ass esl = match ass with$/;"	v
default	Expr.ml	/^  let default d = function $/;"	v	Module:Expr
div_coef	Caml_Smt.ml	/^let rec div_coef exp c = match exp with$/;"	v
div_constr	Caml_Smt.ml	/^let rec div_constr e = match e with$/;"	v
div_func	Caml_Smt.ml	/^let rec div_func exp l = match l with$/;"	v
div_var	Caml_Smt.ml	/^let rec div_var exp v = match exp with$/;"	v
dynTest	Caml.ml	/^  let dynTest sIntv dIntv sAss strCheck ia esl strTestUS =      let olstCheck = toIntList strCheck in$/;"	v
dynamicDecom	Caml.ml	/^  let dynamicDecom assIntv dIntv lstVarID iVar uk_cl esl = $/;"	v
dynamicDecom_pos	Caml.ml	/^  let dynamicDecom_pos assIntv dIntv lstVarID iVar uk_cl esl = $/;"	v
dynamicDecom_test	Caml.ml	/^  let dynamicDecom_test assIntv dIntv lstVarID iVar uk_cl esl t = $/;"	v
e3	Caml_Smt.ml	/^      let (e3, e4, s) = refor_expr e1 c in$/;"	v
e_listVar	Caml.ml	/^  let rec e_listVar e = match e with$/;"	v
e_toAf1	Caml.ml	/^  let rec e_toAf1 ass id numVar = match ass with$/;"	v	Module:Caml
e_toAf2	Caml.ml	/^  let rec e_toAf2 ass id numVar = match ass with$/;"	v	Module:Caml
e_toCai1	Caml.ml	/^  let rec e_toCai1 ass id numVar = match ass with$/;"	v	Module:Caml
e_toCai2	Caml.ml	/^  let rec e_toCai2 ass id numVar = match ass with$/;"	v	Module:Caml
e_toCai3	Caml.ml	/^  let rec e_toCai3 ass id numVar = match ass with$/;"	v	Module:Caml
e_toIntv	Caml.ml	/^  let rec e_toIntv exp = match exp with$/;"	v	Module:Caml
eq	IA.ml	/^  let eq a b = match a with$/;"	v
eval	Expr.ml	/^  let rec eval (exp: Exp.smt_poly_expr) = match exp with $/;"	v	Module:Expr
eval	IA.ml	/^  let eval (a: interval) (b: interval) = $/;"	v
evalAf1	Caml.ml	/^  let rec evalAf1 ass n = function$/;"	v	Module:Caml
evalAf2	Caml.ml	/^  let rec evalAf2 ass n= function$/;"	v	Module:Caml
evalCI	Caml.ml	/^  let rec evalCI ass = function$/;"	v	Module:Caml
evalCai1	Caml.ml	/^  let rec evalCai1 ass n= function$/;"	v	Module:Caml
evalCai2	Caml.ml	/^  let rec evalCai2 ass n= function$/;"	v	Module:Caml
evalCai3	Caml.ml	/^  let rec evalCai3 ass n= function$/;"	v	Module:Caml
evalFloat	Caml.ml	/^  let rec evalFloat ass = function$/;"	v	Module:Caml
evalICI	Caml.ml	/^  let rec evalICI ass = function$/;"	v	Module:Caml
eval_all	Caml.ml	/^   let rec eval_all res us uk_cl e ia assIntv checkVarID= match e with$/;"	v
eval_group	Caml.ml	/^  let rec eval_group ass rm rs tc = match tc with$/;"	v
evaluate	IA.ml	/^      method evaluate =        $/;"	m
evaluate	IA.ml	/^      method evaluate =        $/;"	m	class:af1
extract	Caml.ml	/^  let rec extract lvar ltc tc = match tc with$/;"	v
f	Caml.ml	/^  let rec f r l1 l2 = match l2 with$/;"	v
f	Expr.ml	/^        let f va co acc = $/;"	v
f1	Caml.ml	/^  let rec f1 r l a = match l with$/;"	v
f2	Caml.ml	/^  let rec f2 r l a = match l with$/;"	v
f22	Caml.ml	/^  let rec f22 r l a = match l with$/;"	v
f3	Caml.ml	/^  let rec f3 r l1 l2 = match l2 with$/;"	v
f33	Caml.ml	/^  let rec f33 r l1 l2 = match l2 with$/;"	v
f4	Caml.ml	/^  let rec f4 r l = match l with$/;"	v
f44	Caml.ml	/^  let rec f44 r l = match l with$/;"	v
f_infAssign	Caml.ml	/^  let rec f_infAssign exp = match exp with$/;"	v
f_listVar	Caml.ml	/^  let rec f_listVar e = match e with$/;"	v
f_toList	Caml.ml	/^  let rec f_toList e = match e with$/;"	v
f_toLit	Caml.ml	/^  let rec f_toLit = function $/;"	v	Module:Caml
find_join_clause	Caml.ml	/^    let rec find_join_clause  e lstVar lstConstr = match lstConstr with$/;"	v
find_tc	Caml.ml	/^  let find_tc lvars oAss e uAss = $/;"	v
first_list	Caml.ml	/^      let first_list = List.append sub [first_cons] in$/;"	v
first_search	Caml.ml	/^  let rec first_search lvars oAss uAss first_list = match first_list with$/;"	v
first_word	file.h	/^string first_word (string s){$/;"	f
formula	ast.ml	/^type formula =$/;"	t
ftemp	Caml.ml	/^   let rec ftemp = function$/;"	v
ge	IA.ml	/^  let ge a b = match a with$/;"	v
genAss_test	Caml.ml	/^  let rec genAss_test r g ass esl = match ass with$/;"	v
genCnfCons	Caml.ml	/^    let rec genCnfCons = function$/;"	v
genSatForm	Caml.ml	/^  let genSatForm sIntv esl = $/;"	v
genSmtForm	Caml_Smt.ml	/^let genSmtForm sIntv sAssert loBound upBound =       $/;"	v
gen_constr	file.h	/^string gen_constr (string s){$/;"	f
gen_ftest	Caml.ml	/^  let rec gen_ftest l1 l2 assIntv = match assIntv with$/;"	v
gen_intv	Caml_Smt.ml	/^let rec gen_intv e mb bst bCons= match e with$/;"	v
gen_intv	file.h	/^ string gen_intv (string s){$/;"	f
gen_string	Caml_Smt.ml	/^let gen_string (v, l1, u1, bst, bCons) = $/;"	v
gen_test2	Caml.ml	/^  let gen_test2 x lb ub = $/;"	v
gen_test21	Caml.ml	/^  let gen_test21 x lb ub esl = $/;"	v
gen_test22	Caml.ml	/^  let gen_test22 x lb ub = [(x, lb); (x, ub)]$/;"	v
gen_test3	Caml.ml	/^  let gen_test3 x lb ub = $/;"	v
gen_test31	Caml.ml	/^  let gen_test31 x lb ub = $/;"	v
gen_test4	Caml.ml	/^  let gen_test4 x lb ub = $/;"	v
gen_test_semi3	Caml.ml	/^  let gen_test_semi3 x lb ub = $/;"	v
gen_test_tick	Caml.ml	/^  let gen_test_tick x lb ub esl = $/;"	v
geq	IA.ml	/^  let geq a b = match a with$/;"	v
getAss_expr	Caml_Smt.ml	/^let rec getAss_expr = function$/;"	v	Module:Caml
getAssert	file.h	/^string getAssert (char *filename){$/;"	f
getBound	Caml_Smt.ml	/^let rec getBound (e: smt_bool_expr) = match e with $/;"	v
getIA	file.h	/^int getIA (char *argIA){$/;"	f
getIntv	file.h	/^string getIntv (char *filename){$/;"	f
getLU	Caml.ml	/^   let getLU lit = match lit with$/;"	v
getMB	Caml.ml	/^  let rec getMB m constr = match constr with$/;"	v	Module:Caml
getMaxBound	Caml.ml	/^  let rec getMaxBound m cl = match cl with$/;"	v	Module:Caml
getNumCons	Caml.ml	/^  let getNumCons sAss =$/;"	v
getPositive	Caml.ml	/^  let rec getPositive l iVar = match l with$/;"	v
getVar	Caml.ml	/^  let getVar = function$/;"	v	Module:Caml
get_bExpr	Caml_Smt.ml	/^let rec get_bExpr e = match e with$/;"	v
get_bs	file.h	/^string get_bs (string s){$/;"	f
get_cons	file.h	/^string get_cons (char *filename, int nvar){$/;"	f
get_dep	Caml.ml	/^  let rec get_dep n lst_vars lst = match lst with$/;"	v
get_index	Caml.ml	/^  let rec get_index x ass = match ass with$/;"	v
get_index_all	Caml.ml	/^  let rec get_index_all r varlist ass = match varlist with$/;"	v
get_lbound	file.h	/^string get_lbound (string s){$/;"	f
get_maxdep	Caml.ml	/^  let rec get_maxdep res maxdep olst lst = match lst with$/;"	v
get_mb	file.h	/^string get_mb (string s){$/;"	f
get_minimal	Caml.ml	/^  let rec get_minimal res lst = match lst with$/;"	v
get_pn	Caml.ml	/^  let rec get_pn sign e = match e with$/;"	v
get_pos_neg	Caml.ml	/^  let rec get_pos_neg (pos, neg) sign e = match e with$/;"	v
get_sign	Caml.ml	/^  let rec get_sign sign e = match e with$/;"	v
get_ubound	file.h	/^string get_ubound (string s){$/;"	f
get_unsatcore	Caml.ml	/^  let get_unsatcore f ia assIntv =$/;"	v
get_var	file.h	/^string get_var (string sIn){$/;"	f
get_vars	Caml.ml	/^  let rec get_vars = function$/;"	v	Module:Caml
get_vars	Caml_Smt.ml	/^  let rec get_vars = function$/;"	v
group_cons	Caml.ml	/^  let group_cons listAss listVar = $/;"	v
h	IA.ml	/^      method h = h$/;"	m	class:interval
iVar	Caml.ml	/^      let iVar = (List.length lstLit) + (List.length dlstLit) in$/;"	v
idx	Caml.ml	/^  let rec idx n = match n with$/;"	v	Module:Caml
in_expr	Caml_Smt.ml	/^let rec in_expr e v = match e with$/;"	v
in_list	Caml_Smt.ml	/^let rec in_list l a = match l with$/;"	v
incClause	file.h	/^string incClause (string s){$/;"	f
infCheck	Caml.ml	/^  let infCheck sIntv sAss = $/;"	v
inf_checkSat	Caml.ml	/^  let inf_checkSat e assIntv = $/;"	v
inf_eval_all	Caml.ml	/^   let rec inf_eval_all e assIntv = match e with$/;"	v
inf_max	IA.ml	/^  let inf_max a b = $/;"	v
inf_min	IA.ml	/^  let inf_min a b = $/;"	v
interval	IA.ml	/^  class interval lo hi = object (self)$/;"	c
intv_clause	ast.ml	/^type intv_clause =                         (*interval constraint for each variable*)$/;"	t
intv_expr	ast.ml	/^type intv_expr = $/;"	t
intv_var	file.h	/^string intv_var (string s){$/;"	f
isChildLit	Caml.ml	/^   let isChildLit lit1 lit2 = (*lit2 is a child literal of lit1*)$/;"	v
isReachBound	Caml.ml	/^  let rec isReachBound ass esl = match ass with$/;"	v
isTheoConsis	Caml.ml	/^  let isTheoConsis sIntv sAss strCheck ia =$/;"	v
isUnsat	Caml.ml	/^  let isUnsat fpos neg ia assIntv =$/;"	v
isVar	Caml.ml	/^  let isVar = function$/;"	v	Module:Caml
isVar	Caml_Smt.ml	/^let isVar = function$/;"	v	Module:Caml
is_minimal	Caml.ml	/^  let rec is_minimal l lst = match lst with$/;"	v
is_sat	Caml.ml	/^  let rec is_sat e ass = match e with$/;"	v
is_unsat	Caml.ml	/^  let rec is_unsat lstTest = match lstTest with$/;"	v
k	IA.ml	/^      method k = k$/;"	m	class:af1
k	IA.ml	/^      method k = k$/;"	m	class:af2
k	IA.ml	/^      method k = k$/;"	m	class:caf2
k	IA.ml	/^      method k = k$/;"	m	class:cai1
k	IA.ml	/^      method k = k$/;"	m	class:cai2
k	IA.ml	/^      method k = k$/;"	m	class:cai3
keyAssert	file.h	/^const string keyAssert = "assert";$/;"	v
keyVar	file.h	/^const string keyVar = "declare-var";$/;"	v
kn	IA.ml	/^      method kn = kn$/;"	m	class:af2
kp	IA.ml	/^      method kp = kp$/;"	m	class:af2
l	IA.ml	/^      method l = l$/;"	m	class:interval
l	IA.ml	/^      val mutable l = (lo: float)$/;"	v	class:interval
l1	Caml_Smt.ml	/^  | Add (e1, e2) -> let (l1, a1) = _lstVar e1 in$/;"	v
l1	Caml_Smt.ml	/^  | Sub (e1, e2) -> let (l1, a1) = _lstVar e1 in$/;"	v
l2	Caml_Smt.ml	/^                    let (l2, a2) = _lstVar e2 in$/;"	v
le	IA.ml	/^  let le a b = match a with$/;"	v
leftExp	Caml.ml	/^  let leftExp = function$/;"	v	Module:Caml
length_cons	Caml.ml	/^  let length_cons e = List.length (red_list (bool_vars e))$/;"	v
leq	IA.ml	/^  let leq a b = match a with$/;"	v
let_expr	Exp.ml	/^type let_expr = $/;"	t
lex	SmtLexer.ml	/^let rec lex lexbuf =$/;"	v
lex	lexer.ml	/^let rec lex lexbuf =$/;"	v
list_IDtoLit	Caml.ml	/^   let rec list_IDtoLit l lstIDLit = match l with$/;"	v
list_LittoID	Caml.ml	/^   let rec list_LittoID l lstLitID = match l with$/;"	v
list_group	Caml.ml	/^  let rec list_group r l = match l with$/;"	v
list_remove	Caml_Smt.ml	/^  let list_remove element lst = List.filter (fun x-> x <> element) lst$/;"	v
list_toBool	Caml_Smt.ml	/^  let rec list_toBool lst = match lst with$/;"	v
list_unsat	Caml.ml	/^    let rec list_unsat e ass= match e with$/;"	v
list_unsat	Caml.ml	/^  let rec list_unsat l e ass= match e with$/;"	v
logResult	Caml.ml	/^  let logResult sIntv sAss strCheck ia =$/;"	v
logSat	Caml.ml	/^  let logSat e ia assIntv = $/;"	v
logTest	Caml.ml	/^  let logTest assIntv ass all_cl uk_cl ia = $/;"	v
logTestCase	Caml.ml	/^  let rec logTestCase ass = match ass with$/;"	v
logValue	Caml.ml	/^  let logValue e ass = $/;"	v
logValue_all	Caml.ml	/^    let rec logValue_all e ass = match e with$/;"	v
lst	Caml.ml	/^      let lst = idx iVar in $/;"	v
lstBVar	Caml_Smt.ml	/^let rec lstBVar = function$/;"	v	Module:Caml
lstCheck	Caml.ml	/^      let lstCheck = redLstCheck [] positiveCheck lstIDLit in$/;"	v
lstIDLit	Caml.ml	/^      let lstIDLit = List.combine lst (List.append lstLit dlstLit) in$/;"	v
lstSubVar	Caml_Smt.ml	/^let rec lstSubVar = function$/;"	v	Module:Caml
lstVars	Caml.ml	/^  let lstVars lst = $/;"	v
m	IA.ml	/^      method m = m$/;"	m	class:cai3
m1	IA.ml	/^      method m1 = m1$/;"	m	class:cai2
m2	IA.ml	/^      method m2 = m2$/;"	m	class:cai2
m3	IA.ml	/^      method m3 = m3$/;"	m	class:cai2
main	SmtParser.mli	/^val main :$/;"	v
main	main.cc	/^int main(int argc, char** argv)$/;"	f
main	parser.mli	/^val main :$/;"	v
make_lstIntv	Caml_Smt.ml	/^  let rec make_lstIntv eIntv ub = match eIntv with$/;"	v
max_bound	Caml.ml	/^    let max_bound = getMB 0.0 eIntv in$/;"	v
max_bound	file.h	/^double max_bound (char *filename){$/;"	f
meet	IA.ml	/^       method meet (other: inf_interval) =$/;"	m
meet	IA.ml	/^       method meet (other: interval) =$/;"	m	class:interval
merge_list	Caml.ml	/^  let rec merge_list fpos lstUc = match lstUc with$/;"	v
merge_list	Caml_Smt.ml	/^let merge_list (l1, a) (l2, b) = (List.append l1 l2, a*.b)$/;"	v
minus	Expr.ml	/^  let minus p1 p2 =$/;"	v	Module:Expr
mul	IA.ml	/^      method mul (other: af1) = $/;"	m	class:af1
mul	IA.ml	/^      method mul (other: af2) = $/;"	m	class:af2
mul	IA.ml	/^      method mul (other: caf2) = $/;"	m	class:caf2
mul	IA.ml	/^      method mul (other: cai1) = $/;"	m	class:cai1
mul	IA.ml	/^      method mul (other: cai2) = $/;"	m
mul	IA.ml	/^      method mul (other: cai3) = $/;"	m	class:cai3
mul	IA.ml	/^      method mul (other: inf_interval)= $/;"	m
mul	IA.ml	/^      method mul (other: interval)= $/;"	m	class:interval
mul	IA.ml	/^  let mul (a:bound) (b:bound) =  $/;"	v
mul2	IA.ml	/^       method mul2 (c: float) = $/;"	m
mul2	IA.ml	/^       method mul2 (other: float) = $/;"	m	class:interval
mul2	IA.ml	/^     method mul2 (c: float)=$/;"	m
mul2	IA.ml	/^     method mul2 (c: float)=$/;"	m	class:af1
mul_cons	IA.ml	/^      method mul_cons(c: interval) = $/;"	m	class:cai2
mul_ei	IA.ml	/^      method mul_ei arr = $/;"	m	class:cai2
mul_eij	IA.ml	/^      method mul_eij ma = $/;"	m
mul_eijn	IA.ml	/^      method mul_eijn ma = $/;"	m
mul_ein	IA.ml	/^      method mul_ein arr = $/;"	m
mul_einjn	IA.ml	/^      method mul_einjn ma = $/;"	m
mul_k	IA.ml	/^      method mul_k (k1:interval) = $/;"	m
n	Caml.ml	/^        let n = ref neg in$/;"	v
neg	Caml_Smt.ml	/^  let neg e = match e with$/;"	v
new_uk_cl	Caml.ml	/^	let new_uk_cl = sub_list uk_cl first_list in$/;"	v
nil_expr	Caml_Smt.ml	/^type nil_expr = $/;"	t	Module:Caml
num_var	file.h	/^int num_var(char *filename){$/;"	f
p	Caml.ml	/^        let p = ref pos in$/;"	v
p'	Expr.ml	/^        let p' = Poly.remove v p in $/;"	v
p1	Caml.ml	/^      let (p1, n1) = get_pn sign e1 in$/;"	v
p2	Caml.ml	/^      let (p2, n2) = get_pn sign (Mul (Real (-1.0), e2)) in$/;"	v
p2	Caml.ml	/^      let (p2, n2) = get_pn sign e2 in$/;"	v
para	Caml.ml	/^    let para = int_of_float (max_bound \/. esl) in$/;"	v
plus	Expr.ml	/^  let plus p1 p2 =$/;"	v	Module:Expr
poly_eval	Caml.ml	/^  (*evaluate the bound of poly expression by type of interval arithmetic*)						     let poly_eval e ia assIntv = $/;"	v
poly_expr	ast.ml	/^type poly_expr = $/;"	t
poly_isCons	Caml_Smt.ml	/^let poly_isCons = function$/;"	v
poly_toPrefix	Caml.ml	/^  let rec poly_toPrefix = function$/;"	v
poly_toPrefix	Caml_Smt.ml	/^let rec poly_toPrefix = function$/;"	v
poly_toString	Caml.ml	/^let rec poly_toString sign  = function$/;"	v	Module:Caml
poly_toString	Caml_Smt.ml	/^let rec poly_toString sign  = function$/;"	v
positiveCheck	Caml.ml	/^      let positiveCheck = getPositive olstCheck iVar in$/;"	v
pow	IA.ml	/^       method pow (n: int) = $/;"	m
pow	IA.ml	/^       method pow (n: int) = $/;"	m	class:interval
pow	IA.ml	/^    let rec pow (t: af1) (n: int)= $/;"	v	Module:AF1
pow	IA.ml	/^    let rec pow (t: caf2) (n: int)= $/;"	v	Module:CAF2
pow	IA.ml	/^    let rec pow (t: cai1) (n: int)= $/;"	v	Module:CAI1
pow	IA.ml	/^    let rec pow (t: cai2) (n: int)= $/;"	v	Module:CAI2
pow	IA.ml	/^    let rec pow (t: cai3) (n: int)= $/;"	v	Module:CAI3
pow	IA.ml	/^   let rec pow (t: af2) (n: int)= $/;"	v	Module:AF2
printForm	IA.ml	/^       method printForm =$/;"	m
printForm	IA.ml	/^       method printForm =$/;"	m	class:interval
printForm	IA.ml	/^      method printForm = $/;"	m
printForm	IA.ml	/^      method printForm = $/;"	m	class:af1
printForm	IA.ml	/^      method printForm = $/;"	m	class:caf2
printForm	IA.ml	/^      method printForm = $/;"	m	class:cai1
printForm	IA.ml	/^      method printForm = $/;"	m	class:cai2
printForm	IA.ml	/^      method printForm = $/;"	m	class:cai3
read	Caml.ml	/^  let read s = Parser.main Lexer.lex (Lexing.from_string s)$/;"	v	Module:Caml
read	Caml_Smt.ml	/^let read s = SmtParser.main SmtLexer.lex (Lexing.from_string s)$/;"	v	Module:Caml
readFile	file.h	/^string readFile (char *filename){$/;"	f
redLstCheck	Caml.ml	/^  let rec redLstCheck l1 l2 lstIDLit= match l2 with$/;"	v
red_ass	Caml.ml	/^  let rec red_ass assIntv lstVar = match assIntv with$/;"	v
red_cons	Caml_Smt.ml	/^  let rec red_cons lst = match lst with$/;"	v
red_list	Caml.ml	/^  let red_list l = set_list [] l$/;"	v	Module:Caml
red_list	Caml_Smt.ml	/^  let red_list l = $/;"	v
red_list	Caml_Smt.ml	/^  let red_list l = set_list [] l$/;"	v
reduce	Expr.ml	/^  let reduce (e: Exp.smt_poly_expr) = reify (eval e)$/;"	v
reduce_expr	Caml_Smt.ml	/^  let rec reduce_expr e = match e with $/;"	v
refor_expr	Caml_Smt.ml	/^let rec refor_expr e (c: float) = match e with$/;"	v
rel	Caml.ml	/^  let rec rel e lstAss lstVar = match lstAss with$/;"	v
rel_all	Caml.ml	/^  let rec rel_all l1 l2 lstVar = match l1 with$/;"	v
remLstCheck	Caml.ml	/^  let rec remLstCheck l e lstIDLit= match l with$/;"	v
rem_list	Caml_Smt.ml	/^let rec rem_list l a = match l with$/;"	v
rem_var	Caml_Smt.ml	/^let rem_var e = match e with $/;"	v
rem_var1	Caml_Smt.ml	/^let rem_var1 e =$/;"	v
remain_cons	Caml.ml	/^  let remain_cons gr uk = $/;"	v
remov_nil	Caml_Smt.ml	/^let rec remov_nil expr = match expr with$/;"	v
remove_div	Caml_Smt.ml	/^  let rec remove_div e = match e with$/;"	v
remove_empty	Caml.ml	/^  let rec remove_empty r l = match l with$/;"	v
remove_not	Caml_Smt.ml	/^ let rec remove_not e = match e with $/;"	v
remove_space	file.h	/^string remove_space (string s){$/;"	f
remove_trivial	Caml_Smt.ml	/^  let rec remove_trivial = function$/;"	v
remove_zero	Caml_Smt.ml	/^let rec remove_zero e = match e with$/;"	v
res	Caml.ml	/^	    let res = checkSat e ia assIntv in$/;"	v
res	Caml.ml	/^      let (res, us, uk_cl) = eval_all 1 "" [] eAss ia assIntv checkVarID in$/;"	v
result	IA.ml	/^	let result = new inf_interval val_lo val_hi in$/;"	v
rev	Caml.ml	/^let rev = function$/;"	v	Module:Caml
rev	Caml_Smt.ml	/^let rev = function$/;"	v	Module:Caml
rightExp	Caml.ml	/^  let rightExp = function$/;"	v	Module:Caml
round_off	Caml.ml	/^let round_off (r: float) (n:int) = $/;"	v	Module:Caml
round_test	Caml.ml	/^let rec round_test = function$/;"	v	Module:Caml
s	Caml.ml	/^	let (s, pos1, neg1) = get_pos_neg (pos, neg) sign e1 in$/;"	v
s	Caml.ml	/^      let s = get_sign sign e in$/;"	v
s1	Caml.ml	/^	let (s1, pos1, neg1) = get_pos_neg ([], []) sign e1 in$/;"	v
s1	Caml.ml	/^      let s1 = get_sign sign e1 in$/;"	v
s2	Caml.ml	/^	let (s2, pos2, neg2) = get_pos_neg ([], []) 1.0 e2 in$/;"	v
s2	Caml.ml	/^      let s2 = get_sign 1.0 e2 in$/;"	v
sInterval	Caml.ml	/^	   let (sInterval, sLearn, bump_vars, isDecomp) = dynamicDecom_pos assIntv dIntv checkVarID iVar clTest_US esl in$/;"	v
sLog	Caml.ml	/^	   let sLog = logTest assIntv a eAss uk_cl ia in$/;"	v
sTrivialClause	Caml.ml	/^    let sTrivialClause = "-" ^string_of_int totalVars ^ " " ^string_of_int totalVars^ " 0" in$/;"	v
sat	Caml.ml	/^  let (sat,s) = isConsistent eAss in$/;"	v
sat_find	Caml.ml	/^  let rec sat_find r e vass ass = match ass with$/;"	v
sat_find1	Caml.ml	/^  let rec sat_find1 (e1, d1) r e vass ass = match ass with$/;"	v
sat_group	Caml.ml	/^  let sat_group aAss rmAss rs =$/;"	v
search_inside	Caml.ml	/^  let rec search_inside lvars oAss uAss uk_cl = match uk_cl with$/;"	v
search_sat	Caml.ml	/^  let rec search_sat e ass = match ass with$/;"	v
search_tc2	Caml.ml	/^  let search_tc2 uk_cl assIntv strTestUS esl =      $/;"	v
set_a	IA.ml	/^      method set_a a1 = a<-a1$/;"	m	class:af1
set_a	IA.ml	/^      method set_a a1 = a<-a1$/;"	m	class:af2
set_a	IA.ml	/^      method set_a a1 = a<-a1$/;"	m	class:caf2
set_a	IA.ml	/^      method set_a a1 = a<-a1$/;"	m	class:cai1
set_a	IA.ml	/^      method set_a a1 = a<-a1$/;"	m	class:cai2
set_a	IA.ml	/^      method set_a a1 = a<-a1$/;"	m	class:cai3
set_ar	IA.ml	/^      method set_ar ar1 = ar<-ar1$/;"	m	class:af1
set_ar	IA.ml	/^      method set_ar ar1 = ar<-ar1$/;"	m	class:af2
set_ar	IA.ml	/^      method set_ar ar1 = ar<-ar1$/;"	m	class:caf2
set_ar	IA.ml	/^      method set_ar ar1 = ar<-ar1$/;"	m	class:cai1
set_ar	IA.ml	/^      method set_ar ar1 = ar<-ar1$/;"	m	class:cai2
set_ar	IA.ml	/^      method set_ar ar1 = ar<-ar1$/;"	m	class:cai3
set_h	IA.ml	/^      method set_h h1 = h<-h1$/;"	m	class:interval
set_k	IA.ml	/^      method set_k k1 = k<- abs_float (k1) $/;"	m	class:af1
set_k	IA.ml	/^      method set_k k1 = k<- abs_float (k1) $/;"	m	class:af2
set_k	IA.ml	/^      method set_k k1 = k<- k1 $/;"	m	class:caf2
set_k	IA.ml	/^      method set_k k1 = k<- k1 $/;"	m	class:cai1
set_k	IA.ml	/^      method set_k k1 = k<- k1 $/;"	m	class:cai2
set_k	IA.ml	/^      method set_k k1 = k<- k1 $/;"	m	class:cai3
set_kn	IA.ml	/^      method set_kn kn1 = kn<- abs_float (kn1) $/;"	m	class:af2
set_kp	IA.ml	/^      method set_kp kp1 = kp<- abs_float (kp1) $/;"	m	class:af2
set_l	IA.ml	/^      method set_l l1 = l<-l1$/;"	m	class:interval
set_list	Caml.ml	/^  let rec set_list l1 l2 = match l2 with$/;"	v	Module:Caml
set_list	Caml_Smt.ml	/^  let rec set_list l1 l2 = match l2 with$/;"	v
set_m	IA.ml	/^      method set_m m1 = m<-m1$/;"	m	class:cai3
set_m1	IA.ml	/^      method set_m1 ma1 = m1<-ma1$/;"	m	class:cai2
set_m2	IA.ml	/^      method set_m2 ma2 = m2<-ma2$/;"	m	class:cai2
set_m3	IA.ml	/^      method set_m3 ma3 = m3<-ma3$/;"	m	class:cai2
show	Expr.ml	/^  let show p = Poly.fold (fun vars coeff acc -> (vars, coeff)::acc) p [] $/;"	v	Module:Expr
sign_simp	Caml.ml	/^let sign_simp sign (num: float) = match sign with$/;"	v	Module:Caml
sign_simp	Caml_Smt.ml	/^let sign_simp sign (num: float) = match sign with$/;"	v
simp_cons	Caml_Smt.ml	/^let rec simp_cons  exp = match exp with$/;"	v
simp_expr	Caml_Smt.ml	/^let simp_expr e1 e2 = $/;"	v
simplify_bool	Caml_Smt.ml	/^let rec simplify_bool e = match e with$/;"	v
simplify_expr	Caml_Smt.ml	/^let rec simplify_expr e = match e with$/;"	v
smt_bool_expr	Exp.ml	/^type smt_bool_expr = $/;"	t
smt_intv	file.h	/^string smt_intv (char *filename){$/;"	f
smt_poly_expr	Exp.ml	/^type smt_poly_expr = $/;"	t
sort	Expr.ml	/^  let sort vars = List.sort String.compare vars $/;"	v	Module:Expr
str	Caml.ml	/^	      let str = var_exp e checkVarID in $/;"	v
sub	Caml.ml	/^      let sub = sub_constraints first_cons uk_cl in$/;"	v
sub	IA.ml	/^      method sub (other: af1) = $/;"	m	class:af1
sub	IA.ml	/^      method sub (other: af2) = $/;"	m	class:af2
sub	IA.ml	/^      method sub (other: caf2) = $/;"	m	class:caf2
sub	IA.ml	/^      method sub (other: cai1) = $/;"	m	class:cai1
sub	IA.ml	/^      method sub (other: cai2) = 	$/;"	m	class:cai2
sub	IA.ml	/^      method sub (other: cai3) = $/;"	m	class:cai3
sub	IA.ml	/^      method sub (other: inf_interval)= $/;"	m
sub	IA.ml	/^      method sub (other: interval)= $/;"	m	class:interval
sub2	IA.ml	/^      method sub2 (c: float) = $/;"	m	class:af1
sub2	IA.ml	/^      method sub2 (c: float) = $/;"	m	class:af2
sub2	IA.ml	/^      method sub2 (c: float) = $/;"	m	class:caf2
sub2	IA.ml	/^      method sub2 (c: float) = $/;"	m	class:cai1
sub2	IA.ml	/^      method sub2 (c: float) = $/;"	m	class:cai2
sub2	IA.ml	/^      method sub2 (c: float) = $/;"	m	class:cai3
sub2	IA.ml	/^      method sub2 (c: float)= $/;"	m
sub2	IA.ml	/^      method sub2 (c: float)= $/;"	m	class:interval
sub_ass	Caml.ml	/^  let sub_ass = function$/;"	v	Module:Caml
sub_constraints	Caml.ml	/^  let rec sub_constraints e l = match l with$/;"	v
sub_intv	Caml.ml	/^  let sub_intv = function$/;"	v	Module:Caml
sub_list	Caml.ml	/^  let rec sub_list l1 l2 = $/;"	v
subset_eq	Caml.ml	/^  let subset_eq l1 l2 =$/;"	v
subset_list	Caml.ml	/^  let rec subset_list l1 l2 = match l1 with$/;"	v
subst_bool	Caml_Smt.ml	/^let rec subst_bool bass pass = function$/;"	v	Module:Caml
subst_poly	Caml_Smt.ml	/^let rec subst_poly ass = function$/;"	v	Module:Caml
sum_total_var	Caml.ml	/^  let rec sum_total_var init mb = $/;"	v	Module:Caml
t	Expr.ml	/^    type t = var list $/;"	t	Module:MultiVar
tc	Caml.ml	/^	 let (tc, sTest, clTest_US, a) =  search_tc2 uk_cl assIntv strTestUS esl in$/;"	v
tc	Caml.ml	/^      let (tc, fvars, first_tc, uAss, reason) = first_search [] [] lstTc first_list in$/;"	v
tc1	Caml.ml	/^	let (tc1, lv, satTC, reason) = search_inside fvars first_tc uAss new_uk_cl in$/;"	v
times	Expr.ml	/^  let times p1 p2 = (* naive implementation *) $/;"	v	Module:Expr
tmp	Caml.ml	/^      let tmp = (ftemp checkVarID) ^ ". lstCheck = " ^ (toString_list lstCheck) in$/;"	v
toAf1	Util.ml	/^   let toAf1 (it: IA.interval) (id:int) (size: int) = $/;"	v	Module:Util
toAf2	Util.ml	/^   let toAf2 (it: IA.interval) (id:int) (size: int) = $/;"	v
toCaf2	Util.ml	/^   let toCaf2 (it: IA.interval) (id:int) (size: int) = $/;"	v
toCai1	Util.ml	/^   let toCai1 (it: IA.interval) (id:int) (size: int) = $/;"	v
toCai2	Util.ml	/^   let toCai2 (it: IA.interval) (id:int) (size: int) = $/;"	v
toCai3	Util.ml	/^   let toCai3 (it: IA.interval) (id:int) (size: int) = $/;"	v
toFile_ebg	file.h	/^string toFile_ebg (char * filename){$/;"	f
toFilein	file.h	/^string toFilein (char * filename){$/;"	f
toFileout	file.h	/^string toFileout (char * filename){$/;"	f
toIntList	Caml.ml	/^  let rec toIntList str = $/;"	v	Module:Caml
toPrefix	Caml.ml	/^  let rec toPrefix  = function$/;"	v
toString_ass	Caml.ml	/^  let rec toString_ass assign = match assign with$/;"	v	Module:Caml
toString_list	Caml.ml	/^   let rec toString_list = function$/;"	v
toString_lstIntv	Caml_Smt.ml	/^  let rec toString_lstIntv l = match l with$/;"	v
token	SmtParser.ml	/^type token =$/;"	t
token	SmtParser.mli	/^type token =$/;"	t
token	parser.ml	/^type token =$/;"	t
token	parser.mli	/^type token =$/;"	t
tolist_bc	Caml_Smt.ml	/^  let rec tolist_bc l lb ub = match l with$/;"	v
totalClauses	Caml.ml	/^    let totalClauses = cl + iClause in $/;"	v
totalVars	Caml.ml	/^    let totalVars = 1 + 2* iLit * (sum_total_var 1 para) in$/;"	v
uc_analysis	Caml.ml	/^  let rec uc_analysis fpos flist ia assIntv = match flist with$/;"	v
uc_extract	Caml.ml	/^  let rec uc_extract result initial l = match l with$/;"	v
uk_lit	Caml.ml	/^   let rec uk_lit l1 l2 = match l1 with$/;"	v
uk_reason	Caml.ml	/^  let rec uk_reason l1 l2 = match l1 with$/;"	v
unsat_test	Caml.ml	/^    let rec unsat_test e ass = match ass with$/;"	v
unsat_test	Caml.ml	/^  let rec unsat_test e ass = match ass with$/;"	v
updateClause	file.h	/^int updateClause (char *filename, string newClause){$/;"	f
update_bound	Caml_Smt.ml	/^let rec update_bound (x, lo, up, bCons) = match bCons with$/;"	v
update_list	Caml_Smt.ml	/^  let rec update_list l l1 l2 = match l1 with$/;"	v
update_var	Caml_Smt.ml	/^  let rec update_var (x, lb, ub) l = match l with$/;"	v
v	Expr.ml	/^        let (v,c) = Poly.min_binding p in $/;"	v
valSat	Caml.ml	/^    let rec valSat e ass= match e with$/;"	v
valSat_all	Caml.ml	/^    let rec valSat_all e ass = match ass with$/;"	v
val_hi	IA.ml	/^	let val_hi = $/;"	v
var	Expr.ml	/^type var = string $/;"	t
var_bound	file.h	/^string var_bound (char *filename, int nvar){$/;"	f
var_decomp	Caml.ml	/^  let var_decomp (var, ci) lstVarID code = $/;"	v
var_decomp_neg	Caml.ml	/^  let var_decomp_neg (var, ci) lstVarID code esl = $/;"	v
var_decomp_pn	Caml.ml	/^  let var_decomp_pn (var, ci) lstVarID code = $/;"	v
var_decomp_pos	Caml.ml	/^  let var_decomp_pos (var, ci) lstVarID code esl = $/;"	v
var_decomp_test_both	Caml.ml	/^  let var_decomp_test_both (var, ci) lstVarID code esl tc= $/;"	v
var_decomp_test_neg	Caml.ml	/^  let var_decomp_test_neg (var, ci) lstVarID code esl tc= $/;"	v
var_decomp_test_pos	Caml.ml	/^  let var_decomp_test_pos (var, ci) lstVarID code esl tc= $/;"	v
var_exp	Caml.ml	/^  let var_exp e litID = $/;"	v	Module:Caml
var_exp_list	Caml.ml	/^  let rec var_exp_list lst checkVarID = match lst with$/;"	v
var_list	Caml.ml	/^  let rec var_list lstCheck iVar lstIDLit = match lstCheck with$/;"	v
variable	Expr.ml	/^  let variable v = Poly.singleton [v] 1. $/;"	v	Module:Expr
vars_in_tc	Caml.ml	/^  let rec vars_in_tc tc = match tc with$/;"	v
vars_unbind	Caml.ml	/^  let rec vars_unbind l = match l with$/;"	v
writeFile	file.h	/^int writeFile (char *filename, string content){$/;"	f
x1	Caml_Smt.ml	/^      let (x1, lo1, up1) = update_bound (x, lo, up, e1) in$/;"	v
yyact	SmtParser.ml	/^let yyact = [|$/;"	v
yyact	parser.ml	/^let yyact = [|$/;"	v
yycheck	SmtParser.ml	/^let yycheck = "\\010\\000\\$/;"	v
yycheck	parser.ml	/^let yycheck = "\\019\\000\\$/;"	v
yydefred	SmtParser.ml	/^let yydefred = "\\000\\000\\$/;"	v
yydefred	parser.ml	/^let yydefred = "\\000\\000\\$/;"	v
yydgoto	SmtParser.ml	/^let yydgoto = "\\002\\000\\$/;"	v
yydgoto	parser.ml	/^let yydgoto = "\\002\\000\\$/;"	v
yygindex	SmtParser.ml	/^let yygindex = "\\000\\000\\$/;"	v
yygindex	parser.ml	/^let yygindex = "\\000\\000\\$/;"	v
yylen	SmtParser.ml	/^let yylen = "\\002\\000\\$/;"	v
yylen	parser.ml	/^let yylen = "\\002\\000\\$/;"	v
yylhs	SmtParser.ml	/^let yylhs = "\\255\\255\\$/;"	v
yylhs	parser.ml	/^let yylhs = "\\255\\255\\$/;"	v
yynames_block	SmtParser.ml	/^let yynames_block = "\\$/;"	v
yynames_block	parser.ml	/^let yynames_block = "\\$/;"	v
yynames_const	SmtParser.ml	/^let yynames_const = "\\$/;"	v
yynames_const	parser.ml	/^let yynames_const = "\\$/;"	v
yyrindex	SmtParser.ml	/^let yyrindex = "\\000\\000\\$/;"	v
yyrindex	parser.ml	/^let yyrindex = "\\000\\000\\$/;"	v
yysindex	SmtParser.ml	/^let yysindex = "\\013\\000\\$/;"	v
yysindex	parser.ml	/^let yysindex = "\\007\\000\\$/;"	v
yytable	SmtParser.ml	/^let yytable = "\\027\\000\\$/;"	v
yytable	parser.ml	/^let yytable = "\\043\\000\\$/;"	v
yytablesize	SmtParser.ml	/^let yytablesize = 288$/;"	v
yytablesize	parser.ml	/^let yytablesize = 66$/;"	v
yytransl_block	SmtParser.ml	/^let yytransl_block = [|$/;"	v
yytransl_block	parser.ml	/^let yytransl_block = [|$/;"	v
yytransl_const	SmtParser.ml	/^let yytransl_const = [|$/;"	v
yytransl_const	parser.ml	/^let yytransl_const = [|$/;"	v
